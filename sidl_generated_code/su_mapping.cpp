/*LIC-HDR********************************************************************
**
** Copyright (C) 2005-2011 AtOnce Technologies
**
** This file is part of the Sugar core-system framework.
**
** This file and the associated product may be used and distributed
** under the terms of a current License as defined by AtOnce Technologies
** and appearing in the file LICENSE.TXT included in the packaging of this file.
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
** See http://www.atonce-technologies.com or email info@atonce-technologies.com
** for informations about Sugar Framework and AtOnce Technologies others products
** License Agreements.
**
** Contact info@atonce-technologies.com if any conditions of this license
** are not clear to you.
**
*****************************************************************LIC-HDR*/


// !! This file has been automatically generated by the sugar sidl tool.
// !! Do not edit this file manually under risk of losing your changes.



#include "su_mapping.h"
using namespace su;
using namespace su::util;





namespace
{


	template <typename T>
	void writecontent_var ( T& attr, IDatatree* dtt, map::context& ctxt, pcstr name )
	{
		SU_ASSERT( dtt );
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );

		// optional member ?
		if( !attr.p )
			return;
		
		// ro ?
		if( attr.ro )
			return;

		if( !dtt->ismapping(-1) )
		{
			Strcopy( ctxt.varname, name );
			Strcopy( ctxt.errmsg, "A map is expected !" );
			ctxt.errcode = map::context::EC_MAP_EXPECTED;
			return;
		}

		dtt->push( -1, name );

		if( dtt->isinteger(-1) )
		{
			int v = dtt->asinteger(-1);
			for( int i=0 ; i<attr.n ; i++ )
				attr.set( v, i );
		}
		else if( dtt->isnumber(-1) )
		{
			float v = dtt->asnumber(-1);
			for( int i=0 ; i<attr.n ; i++ )
				attr.set( v, i );
		}
		else if( dtt->isboolean(-1) )
		{
			int v = dtt->asboolean(-1) ? 1 : 0;
			for( int i=0 ; i<attr.n ; i++ )
				attr.set( v, i );
		}
		else if( dtt->isstring(-1) )
		{
			pcstr p = dtt->asstring(-1);
			int   n = Strlen(p);
			if( attr.w != 8 )
			{
				Strcopy( ctxt.varname, name );
				Strcopy( ctxt.errmsg, "String requires 8-bits width attribute !" );
				ctxt.errcode = map::context::EC_STRING_8BITS;
			}
			else if( n > attr.n )
			{
				Strcopy( ctxt.varname, name );
				Strcopy( ctxt.errmsg, "String overflows the attribute reserved area !" );
				ctxt.errcode = map::context::EC_STRING_OVERFLOW;
			}
			else
			{
				ub_copy( attr.p, attr.s, (byte*)p, 0, n*8 );
				ub_zero( attr.p, attr.s+n*8, (attr.n-n)*8 );	// fill with 0!
			}
		}
		else if( dtt->isblob(-1) )
		{
			byte* p; int n;
			p = dtt->asblob(-1,&n);
			if( n*8 > attr.n*attr.w )
			{
				Strcopy( ctxt.varname, name );
				Strcopy( ctxt.errmsg, "Blob overflows the attribute area !" );
				ctxt.errcode = map::context::EC_BLOB_OVERFLOW;
			}
			else
			{
				attr.blit( p, n*8 );
			}
		}
		else if( dtt->isscalar(-1) )
		{
			int v = dtt->tointeger(-1);
			attr.set( v ); 
		}
		else if( dtt->issequence(-1) )
		{
			int n = dtt->size(-1);
			if( n > attr.n )
			{
				Strcopy( ctxt.varname, name );
				Strcopy( ctxt.errmsg, "Sequence has to many elements !" );
				ctxt.errcode = map::context::EC_SEQ_OVERFLOW;
			}
			else
			{
				for( int i=0 ; i<attr.n ; i++ )
				{
					dtt->push(-1,i);
					if( dtt->isnumber(-1) )
						attr.set( dtt->tonumber(-1), i );
					else if( dtt->isinteger(-1) )
						attr.set( dtt->tointeger(-1), i );
					else
						attr.set( 0, i );
					dtt->pop(1);
				}
			}
		}
		else
		{
			Strcopy( ctxt.varname, name );
			Strcopy( ctxt.errmsg, "Unexpected type of dtt node !" );
			ctxt.errcode = map::context::EC_INVALID_TYPE;
		}

		dtt->pop(1);
	}


	StringId push_tag ( IDatatree* dtt, int ith, map::context& ctxt )
	{
		SU_ASSERT( dtt );
		SU_ASSERT( dtt->issequence(-1) );
		SU_REQUIRE_OR_NULL( ctxt.errcode==0 );

		dtt->push(-1,ith);
		if( !dtt->ismapping(-1) )
		{
			Strcopy( ctxt.errmsg, "A mapping table is expected as a tag entry !" );
			ctxt.errcode = map::context::EC_MAP_EXPECTED;
			dtt->pop(1);
			return sid::null;
		}

		dtt->push(-1,"tagid");
		if( !dtt->isstring(-1) )
		{
			Strcopy( ctxt.errmsg, "A tag must be identified using the key 'tagid' !" );
			ctxt.errcode = map::context::EC_TAGID_MISSING;
			dtt->pop(2);
			return sid::null;
		}

		pcstr tagid = dtt->asstring(-1);
		dtt->pop(1);

		return sid::Find(tagid);
	}


	uint get_tag_req ( IDatatree* dtt, pcstr inchain, map::context& ctxt )
	{
		SU_ASSERT( dtt );
		SU_ASSERT( dtt->ismapping(-1) );
		SU_REQUIRE_OR_NULL( ctxt.errcode==0 );

		dtt->pushchain( -1, inchain );

		if( !dtt->isscalar(-1) || dtt->isblob(-1) )
		{
			Strformat( ctxt.errmsg, "The member '%s' is required !", inchain );
			ctxt.errcode = map::context::EC_MEMBER_MISSING;
			dtt->pop(1);
			return 0;
		}
		else
		{
			uint v = dtt->tointeger(-1);
			dtt->pop(1);
			return v;
		}
	}


}






namespace
{


	void writecontent_rec_elements ( map::elements& o, IDatatree* dtt, map::context& ctxt, pcstr sub=NULL )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.recname, SU_VERBOSE_STR("elements") );
		if(sub) dtt->push(-1,sub);
		writecontent_var(o.count,dtt,ctxt,SU_VERBOSE_STR("count"));
		writecontent_var(o.ids,dtt,ctxt,SU_VERBOSE_STR("ids"));
		if(sub) dtt->pop(1);
		if( ctxt.errcode==0 ) ctxt.recname[0]=0;
	}


	void writecontent_rec_string ( map::string& o, IDatatree* dtt, map::context& ctxt, pcstr sub=NULL )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.recname, SU_VERBOSE_STR("string") );
		if(sub) dtt->push(-1,sub);
		writecontent_var(o.len,dtt,ctxt,SU_VERBOSE_STR("len"));
		writecontent_var(o.text,dtt,ctxt,SU_VERBOSE_STR("text"));
		if(sub) dtt->pop(1);
		if( ctxt.errcode==0 ) ctxt.recname[0]=0;
	}


	void writecontent_rec_quat ( map::quat& o, IDatatree* dtt, map::context& ctxt, pcstr sub=NULL )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.recname, SU_VERBOSE_STR("quat") );
		if(sub) dtt->push(-1,sub);
		writecontent_var(o.x,dtt,ctxt,SU_VERBOSE_STR("x"));
		writecontent_var(o.y,dtt,ctxt,SU_VERBOSE_STR("y"));
		writecontent_var(o.z,dtt,ctxt,SU_VERBOSE_STR("z"));
		writecontent_var(o.w,dtt,ctxt,SU_VERBOSE_STR("w"));
		if(sub) dtt->pop(1);
		if( ctxt.errcode==0 ) ctxt.recname[0]=0;
	}


	void writecontent_rec_vec3 ( map::vec3& o, IDatatree* dtt, map::context& ctxt, pcstr sub=NULL )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.recname, SU_VERBOSE_STR("vec3") );
		if(sub) dtt->push(-1,sub);
		writecontent_var(o.x,dtt,ctxt,SU_VERBOSE_STR("x"));
		writecontent_var(o.y,dtt,ctxt,SU_VERBOSE_STR("y"));
		writecontent_var(o.z,dtt,ctxt,SU_VERBOSE_STR("z"));
		if(sub) dtt->pop(1);
		if( ctxt.errcode==0 ) ctxt.recname[0]=0;
	}


	void writecontent_rec_locations ( map::locations& o, IDatatree* dtt, map::context& ctxt, pcstr sub=NULL )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.recname, SU_VERBOSE_STR("locations") );
		if(sub) dtt->push(-1,sub);
		writecontent_var(o.count,dtt,ctxt,SU_VERBOSE_STR("count"));
		writecontent_var(o.x,dtt,ctxt,SU_VERBOSE_STR("x"));
		writecontent_var(o.y,dtt,ctxt,SU_VERBOSE_STR("y"));
		writecontent_var(o.z,dtt,ctxt,SU_VERBOSE_STR("z"));
		if(sub) dtt->pop(1);
		if( ctxt.errcode==0 ) ctxt.recname[0]=0;
	}


	void writecontent_rec_element ( map::element& o, IDatatree* dtt, map::context& ctxt, pcstr sub=NULL )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.recname, SU_VERBOSE_STR("element") );
		if(sub) dtt->push(-1,sub);
		writecontent_var(o.id,dtt,ctxt,SU_VERBOSE_STR("id"));
		if(sub) dtt->pop(1);
		if( ctxt.errcode==0 ) ctxt.recname[0]=0;
	}


	void writecontent_rec_matrix ( map::matrix& o, IDatatree* dtt, map::context& ctxt, pcstr sub=NULL )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.recname, SU_VERBOSE_STR("matrix") );
		if(sub) dtt->push(-1,sub);
		writecontent_var(o.coeff,dtt,ctxt,SU_VERBOSE_STR("coeff"));
		if(sub) dtt->pop(1);
		if( ctxt.errcode==0 ) ctxt.recname[0]=0;
	}


	void writecontent_rec_bitmask ( map::bitmask& o, IDatatree* dtt, map::context& ctxt, pcstr sub=NULL )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.recname, SU_VERBOSE_STR("bitmask") );
		if(sub) dtt->push(-1,sub);
		writecontent_var(o.size,dtt,ctxt,SU_VERBOSE_STR("size"));
		writecontent_var(o.bits,dtt,ctxt,SU_VERBOSE_STR("bits"));
		if(sub) dtt->pop(1);
		if( ctxt.errcode==0 ) ctxt.recname[0]=0;
	}


	void writecontent_rec_rscs ( map::rscs& o, IDatatree* dtt, map::context& ctxt, pcstr sub=NULL )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.recname, SU_VERBOSE_STR("rscs") );
		if(sub) dtt->push(-1,sub);
		writecontent_var(o.count,dtt,ctxt,SU_VERBOSE_STR("count"));
		writecontent_var(o.ids,dtt,ctxt,SU_VERBOSE_STR("ids"));
		if(sub) dtt->pop(1);
		if( ctxt.errcode==0 ) ctxt.recname[0]=0;
	}


	void writecontent_rec_blob ( map::blob& o, IDatatree* dtt, map::context& ctxt, pcstr sub=NULL )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.recname, SU_VERBOSE_STR("blob") );
		if(sub) dtt->push(-1,sub);
		writecontent_var(o.size,dtt,ctxt,SU_VERBOSE_STR("size"));
		writecontent_var(o.bytes,dtt,ctxt,SU_VERBOSE_STR("bytes"));
		if(sub) dtt->pop(1);
		if( ctxt.errcode==0 ) ctxt.recname[0]=0;
	}


	void writecontent_rec_vec4 ( map::vec4& o, IDatatree* dtt, map::context& ctxt, pcstr sub=NULL )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.recname, SU_VERBOSE_STR("vec4") );
		if(sub) dtt->push(-1,sub);
		writecontent_var(o.x,dtt,ctxt,SU_VERBOSE_STR("x"));
		writecontent_var(o.y,dtt,ctxt,SU_VERBOSE_STR("y"));
		writecontent_var(o.z,dtt,ctxt,SU_VERBOSE_STR("z"));
		writecontent_var(o.w,dtt,ctxt,SU_VERBOSE_STR("w"));
		if(sub) dtt->pop(1);
		if( ctxt.errcode==0 ) ctxt.recname[0]=0;
	}


	void writecontent_rec_rsc ( map::rsc& o, IDatatree* dtt, map::context& ctxt, pcstr sub=NULL )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.recname, SU_VERBOSE_STR("rsc") );
		if(sub) dtt->push(-1,sub);
		writecontent_var(o.id,dtt,ctxt,SU_VERBOSE_STR("id"));
		if(sub) dtt->pop(1);
		if( ctxt.errcode==0 ) ctxt.recname[0]=0;
	}


	void writecontent_rec_strings ( map::strings& o, IDatatree* dtt, map::context& ctxt, pcstr sub=NULL )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.recname, SU_VERBOSE_STR("strings") );
		if(sub) dtt->push(-1,sub);
		writecontent_var(o.count,dtt,ctxt,SU_VERBOSE_STR("count"));
		writecontent_var(o.len,dtt,ctxt,SU_VERBOSE_STR("len"));
		writecontent_var(o.offsets,dtt,ctxt,SU_VERBOSE_STR("offsets"));
		writecontent_var(o.texts,dtt,ctxt,SU_VERBOSE_STR("texts"));
		if(sub) dtt->pop(1);
		if( ctxt.errcode==0 ) ctxt.recname[0]=0;
	}


	void writecontent_rec_box3 ( map::box3& o, IDatatree* dtt, map::context& ctxt, pcstr sub=NULL )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.recname, SU_VERBOSE_STR("box3") );
		if(sub) dtt->push(-1,sub);
		writecontent_var(o.center,dtt,ctxt,SU_VERBOSE_STR("center"));
		writecontent_var(o.rotation,dtt,ctxt,SU_VERBOSE_STR("rotation"));
		writecontent_var(o.length,dtt,ctxt,SU_VERBOSE_STR("length"));
		if(sub) dtt->pop(1);
		if( ctxt.errcode==0 ) ctxt.recname[0]=0;
	}


	void writecontent_rec_location ( map::location& o, IDatatree* dtt, map::context& ctxt, pcstr sub=NULL )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.recname, SU_VERBOSE_STR("location") );
		if(sub) dtt->push(-1,sub);
		writecontent_var(o.x,dtt,ctxt,SU_VERBOSE_STR("x"));
		writecontent_var(o.y,dtt,ctxt,SU_VERBOSE_STR("y"));
		writecontent_var(o.z,dtt,ctxt,SU_VERBOSE_STR("z"));
		if(sub) dtt->pop(1);
		if( ctxt.errcode==0 ) ctxt.recname[0]=0;
	}


	void writecontent_tag_rsc_collection_anim_skelframe ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_anim_skelframe") );
		map::rsc_collection_anim_skelframe t;
		map::rsc_collection_anim_skelframe::requirements req;
		req.bonecnt = get_tag_req(dtt,"bonecnt",ctxt);
		req.framecnt = get_tag_req(dtt,"framecnt",ctxt);
		m.tag_add(t,req);
		writecontent_var(t.freq,dtt,ctxt,"freq");
		writecontent_var(t.bonecnt,dtt,ctxt,"bonecnt");
		writecontent_var(t.bonenames,dtt,ctxt,"bonenames");
		writecontent_var(t.framecnt,dtt,ctxt,"framecnt");
		writecontent_var(t.frames,dtt,ctxt,"frames");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_bitmap_dxmip ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_bitmap_dxmip") );
		map::rsc_collection_bitmap_dxmip t;
		map::rsc_collection_bitmap_dxmip::requirements req;
		req.size = get_tag_req(dtt,"size",ctxt);
		m.tag_add(t,req);
		writecontent_var(t.format,dtt,ctxt,"format");
		writecontent_var(t.size,dtt,ctxt,"size");
		writecontent_var(t.data,dtt,ctxt,"data");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_litem_character ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_litem_character") );
		map::rsc_collection_litem_character t;
		map::rsc_collection_litem_character::requirements req;
		req.name_len = get_tag_req(dtt,"name.len",ctxt);
		req.note_len = get_tag_req(dtt,"note.len",ctxt);
		m.tag_add(t,req);
		writecontent_var(t.parentidx,dtt,ctxt,"parentidx");
		writecontent_rec_string(t.name,dtt,ctxt,"name");
		writecontent_rec_string(t.note,dtt,ctxt,"note");
		writecontent_var(t.hidden,dtt,ctxt,"hidden");
		writecontent_rec_matrix(t.trs,dtt,ctxt,"trs");
		writecontent_var(t.trsanimid,dtt,ctxt,"trsanimid");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_hotpoint ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_hotpoint") );
		map::rsc_collection_hotpoint t;
		m.tag_add(t);
		writecontent_var(t.namecrc,dtt,ctxt,"namecrc");
		writecontent_rec_location(t.spot,dtt,ctxt,"spot");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_hotspline ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_hotspline") );
		map::rsc_collection_hotspline t;
		m.tag_add(t);
		writecontent_var(t.namecrc,dtt,ctxt,"namecrc");
		writecontent_rec_location(t.start,dtt,ctxt,"start");
		writecontent_rec_location(t.end,dtt,ctxt,"end");
		writecontent_rec_vec3(t.intan,dtt,ctxt,"intan");
		writecontent_rec_vec3(t.outan,dtt,ctxt,"outan");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_litem_light ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_litem_light") );
		map::rsc_collection_litem_light t;
		map::rsc_collection_litem_light::requirements req;
		req.name_len = get_tag_req(dtt,"name.len",ctxt);
		req.note_len = get_tag_req(dtt,"note.len",ctxt);
		m.tag_add(t,req);
		writecontent_var(t.parentidx,dtt,ctxt,"parentidx");
		writecontent_rec_string(t.name,dtt,ctxt,"name");
		writecontent_rec_string(t.note,dtt,ctxt,"note");
		writecontent_var(t.hidden,dtt,ctxt,"hidden");
		writecontent_rec_matrix(t.trs,dtt,ctxt,"trs");
		writecontent_var(t.trsanimid,dtt,ctxt,"trsanimid");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_litem_camera ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_litem_camera") );
		map::rsc_collection_litem_camera t;
		map::rsc_collection_litem_camera::requirements req;
		req.name_len = get_tag_req(dtt,"name.len",ctxt);
		req.note_len = get_tag_req(dtt,"note.len",ctxt);
		m.tag_add(t,req);
		writecontent_var(t.parentidx,dtt,ctxt,"parentidx");
		writecontent_rec_string(t.name,dtt,ctxt,"name");
		writecontent_rec_string(t.note,dtt,ctxt,"note");
		writecontent_var(t.hidden,dtt,ctxt,"hidden");
		writecontent_rec_matrix(t.trs,dtt,ctxt,"trs");
		writecontent_var(t.trsanimid,dtt,ctxt,"trsanimid");
		writecontent_var(t.fov,dtt,ctxt,"fov");
		writecontent_var(t.fovanimid,dtt,ctxt,"fovanimid");
		writecontent_var(t.targetdist,dtt,ctxt,"targetdist");
		writecontent_var(t.envrange,dtt,ctxt,"envrange");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_litem_bone ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_litem_bone") );
		map::rsc_collection_litem_bone t;
		map::rsc_collection_litem_bone::requirements req;
		req.name_len = get_tag_req(dtt,"name.len",ctxt);
		req.note_len = get_tag_req(dtt,"note.len",ctxt);
		m.tag_add(t,req);
		writecontent_var(t.parentidx,dtt,ctxt,"parentidx");
		writecontent_rec_string(t.name,dtt,ctxt,"name");
		writecontent_rec_string(t.note,dtt,ctxt,"note");
		writecontent_var(t.hidden,dtt,ctxt,"hidden");
		writecontent_rec_matrix(t.trs,dtt,ctxt,"trs");
		writecontent_var(t.trsanimid,dtt,ctxt,"trsanimid");
		writecontent_var(t.length,dtt,ctxt,"length");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_userdata_content ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_userdata_content") );
		map::rsc_userdata_content t;
		map::rsc_userdata_content::requirements req;
		req.label_len = get_tag_req(dtt,"label.len",ctxt);
		req.sourcefile_len = get_tag_req(dtt,"sourcefile.len",ctxt);
		req.data_size = get_tag_req(dtt,"data.size",ctxt);
		m.tag_add(t,req);
		writecontent_rec_string(t.label,dtt,ctxt,"label");
		writecontent_rec_string(t.sourcefile,dtt,ctxt,"sourcefile");
		writecontent_rec_blob(t.data,dtt,ctxt,"data");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_hotsphere ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_hotsphere") );
		map::rsc_collection_hotsphere t;
		m.tag_add(t);
		writecontent_var(t.namecrc,dtt,ctxt,"namecrc");
		writecontent_rec_location(t.center,dtt,ctxt,"center");
		writecontent_var(t.radius,dtt,ctxt,"radius");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_shading_technique ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_shading_technique") );
		map::rsc_collection_shading_technique t;
		map::rsc_collection_shading_technique::requirements req;
		req.name_len = get_tag_req(dtt,"name.len",ctxt);
		req.note_len = get_tag_req(dtt,"note.len",ctxt);
		m.tag_add(t,req);
		writecontent_rec_string(t.name,dtt,ctxt,"name");
		writecontent_var(t.namecrc,dtt,ctxt,"namecrc");
		writecontent_rec_string(t.note,dtt,ctxt,"note");
		writecontent_var(t.passcnt,dtt,ctxt,"passcnt");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_bitmap_s3mip ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_bitmap_s3mip") );
		map::rsc_collection_bitmap_s3mip t;
		map::rsc_collection_bitmap_s3mip::requirements req;
		req.size = get_tag_req(dtt,"size",ctxt);
		m.tag_add(t,req);
		writecontent_var(t.format,dtt,ctxt,"format");
		writecontent_var(t.size,dtt,ctxt,"size");
		writecontent_var(t.data,dtt,ctxt,"data");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_skeleton ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_skeleton") );
		map::rsc_collection_skeleton t;
		map::rsc_collection_skeleton::requirements req;
		req.note_len = get_tag_req(dtt,"note.len",ctxt);
		m.tag_add(t,req);
		writecontent_rec_box3(t.bbox,dtt,ctxt,"bbox");
		writecontent_rec_string(t.note,dtt,ctxt,"note");
		writecontent_var(t.bonecnt,dtt,ctxt,"bonecnt");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_mesh_blendprocess ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_mesh_blendprocess") );
		map::rsc_collection_mesh_blendprocess t;
		map::rsc_collection_mesh_blendprocess::requirements req;
		req.vcount = get_tag_req(dtt,"vcount",ctxt);
		req.vstride = get_tag_req(dtt,"vstride",ctxt);
		req.bcount = get_tag_req(dtt,"bcount",ctxt);
		m.tag_add(t,req);
		writecontent_var(t.vbidx,dtt,ctxt,"vbidx");
		writecontent_var(t.vcount,dtt,ctxt,"vcount");
		writecontent_var(t.vstride,dtt,ctxt,"vstride");
		writecontent_var(t.vertices,dtt,ctxt,"vertices");
		writecontent_var(t.bcount,dtt,ctxt,"bcount");
		writecontent_var(t.bones,dtt,ctxt,"bones");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_bitmap_drivermip ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_bitmap_drivermip") );
		map::rsc_collection_bitmap_drivermip t;
		map::rsc_collection_bitmap_drivermip::requirements req;
		req.size = get_tag_req(dtt,"size",ctxt);
		m.tag_add(t,req);
		writecontent_var(t.format,dtt,ctxt,"format");
		writecontent_var(t.size,dtt,ctxt,"size");
		writecontent_var(t.data,dtt,ctxt,"data");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_litem_geometry ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_litem_geometry") );
		map::rsc_collection_litem_geometry t;
		map::rsc_collection_litem_geometry::requirements req;
		req.name_len = get_tag_req(dtt,"name.len",ctxt);
		req.note_len = get_tag_req(dtt,"note.len",ctxt);
		m.tag_add(t,req);
		writecontent_var(t.parentidx,dtt,ctxt,"parentidx");
		writecontent_rec_string(t.name,dtt,ctxt,"name");
		writecontent_rec_string(t.note,dtt,ctxt,"note");
		writecontent_var(t.hidden,dtt,ctxt,"hidden");
		writecontent_rec_matrix(t.trs,dtt,ctxt,"trs");
		writecontent_var(t.trsanimid,dtt,ctxt,"trsanimid");
		writecontent_rec_matrix(t.offset,dtt,ctxt,"offset");
		writecontent_var(t.meshid,dtt,ctxt,"meshid");
		writecontent_var(t.color,dtt,ctxt,"color");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_anim_klin_scl ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_anim_klin_scl") );
		map::rsc_collection_anim_klin_scl t;
		map::rsc_collection_anim_klin_scl::requirements req;
		req.keycnt = get_tag_req(dtt,"keycnt",ctxt);
		m.tag_add(t,req);
		writecontent_var(t.ort,dtt,ctxt,"ort");
		writecontent_var(t.samplingrate,dtt,ctxt,"samplingrate");
		writecontent_var(t.keycnt,dtt,ctxt,"keycnt");
		writecontent_var(t.keys,dtt,ctxt,"keys");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_anim ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_anim") );
		map::rsc_collection_anim t;
		m.tag_add(t);
		writecontent_rec_box3(t.bbox,dtt,ctxt,"bbox");
		writecontent_var(t.timerange,dtt,ctxt,"timerange");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_bitmap_glmip ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_bitmap_glmip") );
		map::rsc_collection_bitmap_glmip t;
		map::rsc_collection_bitmap_glmip::requirements req;
		req.size = get_tag_req(dtt,"size",ctxt);
		m.tag_add(t,req);
		writecontent_var(t.format,dtt,ctxt,"format");
		writecontent_var(t.type,dtt,ctxt,"type");
		writecontent_var(t.size,dtt,ctxt,"size");
		writecontent_var(t.data,dtt,ctxt,"data");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_anim_klin_rot ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_anim_klin_rot") );
		map::rsc_collection_anim_klin_rot t;
		map::rsc_collection_anim_klin_rot::requirements req;
		req.keycnt = get_tag_req(dtt,"keycnt",ctxt);
		m.tag_add(t,req);
		writecontent_var(t.ort,dtt,ctxt,"ort");
		writecontent_var(t.samplingrate,dtt,ctxt,"samplingrate");
		writecontent_var(t.keycnt,dtt,ctxt,"keycnt");
		writecontent_var(t.keys,dtt,ctxt,"keys");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_shading_pass ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_shading_pass") );
		map::rsc_collection_shading_pass t;
		m.tag_add(t);
		writecontent_var(t.psidx,dtt,ctxt,"psidx");
		writecontent_var(t.vsidx,dtt,ctxt,"vsidx");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_skeleton_bone ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_skeleton_bone") );
		map::rsc_collection_skeleton_bone t;
		map::rsc_collection_skeleton_bone::requirements req;
		req.name_len = get_tag_req(dtt,"name.len",ctxt);
		req.note_len = get_tag_req(dtt,"note.len",ctxt);
		m.tag_add(t,req);
		writecontent_rec_string(t.name,dtt,ctxt,"name");
		writecontent_var(t.namecrc,dtt,ctxt,"namecrc");
		writecontent_var(t.parentidx,dtt,ctxt,"parentidx");
		writecontent_rec_string(t.note,dtt,ctxt,"note");
		writecontent_var(t.pose,dtt,ctxt,"pose");
		writecontent_rec_matrix(t.tobonetr,dtt,ctxt,"tobonetr");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_anim_morphframe ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_anim_morphframe") );
		map::rsc_collection_anim_morphframe t;
		map::rsc_collection_anim_morphframe::requirements req;
		req.targetcnt = get_tag_req(dtt,"targetcnt",ctxt);
		req.framecnt = get_tag_req(dtt,"framecnt",ctxt);
		m.tag_add(t,req);
		writecontent_var(t.freq,dtt,ctxt,"freq");
		writecontent_var(t.targetcnt,dtt,ctxt,"targetcnt");
		writecontent_var(t.tnames,dtt,ctxt,"tnames");
		writecontent_var(t.tdownlim,dtt,ctxt,"tdownlim");
		writecontent_var(t.tuplim,dtt,ctxt,"tuplim");
		writecontent_var(t.framecnt,dtt,ctxt,"framecnt");
		writecontent_var(t.frames,dtt,ctxt,"frames");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_bitmap_pvrmip ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_bitmap_pvrmip") );
		map::rsc_collection_bitmap_pvrmip t;
		map::rsc_collection_bitmap_pvrmip::requirements req;
		req.size = get_tag_req(dtt,"size",ctxt);
		m.tag_add(t,req);
		writecontent_var(t.format,dtt,ctxt,"format");
		writecontent_var(t.size,dtt,ctxt,"size");
		writecontent_var(t.data,dtt,ctxt,"data");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_sourcefile ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_sourcefile") );
		map::rsc_collection_sourcefile t;
		map::rsc_collection_sourcefile::requirements req;
		req.filename_len = get_tag_req(dtt,"filename.len",ctxt);
		m.tag_add(t,req);
		writecontent_rec_string(t.filename,dtt,ctxt,"filename");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_hotbox ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_hotbox") );
		map::rsc_collection_hotbox t;
		m.tag_add(t);
		writecontent_var(t.namecrc,dtt,ctxt,"namecrc");
		writecontent_rec_box3(t.box,dtt,ctxt,"box");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_mesh_blendpass ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_mesh_blendpass") );
		map::rsc_collection_mesh_blendpass t;
		map::rsc_collection_mesh_blendpass::requirements req;
		req.arity = get_tag_req(dtt,"arity",ctxt);
		req.count = get_tag_req(dtt,"count",ctxt);
		m.tag_add(t,req);
		writecontent_var(t.arity,dtt,ctxt,"arity");
		writecontent_var(t.count,dtt,ctxt,"count");
		writecontent_var(t.bw,dtt,ctxt,"bw");
		writecontent_var(t.bidx,dtt,ctxt,"bidx");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_list ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_list") );
		map::rsc_collection_list t;
		map::rsc_collection_list::requirements req;
		req.name_len = get_tag_req(dtt,"name.len",ctxt);
		m.tag_add(t,req);
		writecontent_rec_string(t.name,dtt,ctxt,"name");
		writecontent_var(t.count,dtt,ctxt,"count");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_hotsegment ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_hotsegment") );
		map::rsc_collection_hotsegment t;
		m.tag_add(t);
		writecontent_var(t.namecrc,dtt,ctxt,"namecrc");
		writecontent_rec_location(t.start,dtt,ctxt,"start");
		writecontent_rec_location(t.end,dtt,ctxt,"end");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_hotcloud ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_hotcloud") );
		map::rsc_collection_hotcloud t;
		map::rsc_collection_hotcloud::requirements req;
		req.spots_count = get_tag_req(dtt,"spots.count",ctxt);
		m.tag_add(t,req);
		writecontent_var(t.namecrc,dtt,ctxt,"namecrc");
		writecontent_rec_locations(t.spots,dtt,ctxt,"spots");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_mesh ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_mesh") );
		map::rsc_collection_mesh t;
		m.tag_add(t);
		writecontent_rec_box3(t.bbox,dtt,ctxt,"bbox");
		writecontent_var(t.skeletonid,dtt,ctxt,"skeletonid");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_litem_helper ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_litem_helper") );
		map::rsc_collection_litem_helper t;
		map::rsc_collection_litem_helper::requirements req;
		req.name_len = get_tag_req(dtt,"name.len",ctxt);
		req.note_len = get_tag_req(dtt,"note.len",ctxt);
		m.tag_add(t,req);
		writecontent_var(t.parentidx,dtt,ctxt,"parentidx");
		writecontent_rec_string(t.name,dtt,ctxt,"name");
		writecontent_rec_string(t.note,dtt,ctxt,"note");
		writecontent_var(t.hidden,dtt,ctxt,"hidden");
		writecontent_rec_matrix(t.trs,dtt,ctxt,"trs");
		writecontent_var(t.trsanimid,dtt,ctxt,"trsanimid");
		writecontent_var(t.width,dtt,ctxt,"width");
		writecontent_var(t.height,dtt,ctxt,"height");
		writecontent_var(t.depth,dtt,ctxt,"depth");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_litem_export ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_litem_export") );
		map::rsc_collection_litem_export t;
		map::rsc_collection_litem_export::requirements req;
		req.name_len = get_tag_req(dtt,"name.len",ctxt);
		m.tag_add(t,req);
		writecontent_var(t.objectid,dtt,ctxt,"objectid");
		writecontent_rec_string(t.name,dtt,ctxt,"name");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_mesh_surface ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_mesh_surface") );
		map::rsc_collection_mesh_surface t;
		map::rsc_collection_mesh_surface::requirements req;
		req.shdparams_len = get_tag_req(dtt,"shdparams.len",ctxt);
		req.texids_count = get_tag_req(dtt,"texids.count",ctxt);
		m.tag_add(t,req);
		writecontent_var(t.vboidx,dtt,ctxt,"vboidx");
		writecontent_var(t.effectid,dtt,ctxt,"effectid");
		writecontent_var(t.techniqueidx,dtt,ctxt,"techniqueidx");
		writecontent_rec_string(t.shdparams,dtt,ctxt,"shdparams");
		writecontent_rec_elements(t.texids,dtt,ctxt,"texids");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_anim_klin_float ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_anim_klin_float") );
		map::rsc_collection_anim_klin_float t;
		map::rsc_collection_anim_klin_float::requirements req;
		req.keycnt = get_tag_req(dtt,"keycnt",ctxt);
		m.tag_add(t,req);
		writecontent_var(t.ort,dtt,ctxt,"ort");
		writecontent_var(t.samplingrate,dtt,ctxt,"samplingrate");
		writecontent_var(t.keycnt,dtt,ctxt,"keycnt");
		writecontent_var(t.keys,dtt,ctxt,"keys");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_shading_effect ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_shading_effect") );
		map::rsc_collection_shading_effect t;
		map::rsc_collection_shading_effect::requirements req;
		req.name_len = get_tag_req(dtt,"name.len",ctxt);
		req.note_len = get_tag_req(dtt,"note.len",ctxt);
		m.tag_add(t,req);
		writecontent_rec_string(t.name,dtt,ctxt,"name");
		writecontent_rec_string(t.note,dtt,ctxt,"note");
		writecontent_var(t.techcnt,dtt,ctxt,"techcnt");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_define ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_define") );
		map::rsc_collection_define t;
		m.tag_add(t);
		writecontent_var(t.id,dtt,ctxt,"id");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_anim_note ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_anim_note") );
		map::rsc_collection_anim_note t;
		map::rsc_collection_anim_note::requirements req;
		req.keycnt = get_tag_req(dtt,"keycnt",ctxt);
		req.notes_len = get_tag_req(dtt,"notes.len",ctxt);
		m.tag_add(t,req);
		writecontent_var(t.keycnt,dtt,ctxt,"keycnt");
		writecontent_var(t.keys,dtt,ctxt,"keys");
		writecontent_rec_strings(t.notes,dtt,ctxt,"notes");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_bitmap ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_bitmap") );
		map::rsc_collection_bitmap t;
		m.tag_add(t);
		writecontent_var(t.width,dtt,ctxt,"width");
		writecontent_var(t.height,dtt,ctxt,"height");
		writecontent_var(t.wpad,dtt,ctxt,"wpad");
		writecontent_var(t.hpad,dtt,ctxt,"hpad");
		writecontent_var(t.astatus,dtt,ctxt,"astatus");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_shading_ps ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_shading_ps") );
		map::rsc_collection_shading_ps t;
		map::rsc_collection_shading_ps::requirements req;
		req.data_size = get_tag_req(dtt,"data.size",ctxt);
		m.tag_add(t,req);
		writecontent_rec_blob(t.data,dtt,ctxt,"data");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_shading_gs ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_shading_gs") );
		map::rsc_collection_shading_gs t;
		map::rsc_collection_shading_gs::requirements req;
		req.data_size = get_tag_req(dtt,"data.size",ctxt);
		m.tag_add(t,req);
		writecontent_rec_blob(t.data,dtt,ctxt,"data");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_morph_target ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_morph_target") );
		map::rsc_collection_morph_target t;
		map::rsc_collection_morph_target::requirements req;
		req.name_len = get_tag_req(dtt,"name.len",ctxt);
		req.vtxcnt = get_tag_req(dtt,"vtxcnt",ctxt);
		m.tag_add(t,req);
		writecontent_rec_string(t.name,dtt,ctxt,"name");
		writecontent_var(t.namecrc,dtt,ctxt,"namecrc");
		writecontent_var(t.vtxcnt,dtt,ctxt,"vtxcnt");
		writecontent_var(t.vtxidx,dtt,ctxt,"vtxidx");
		writecontent_var(t.vtxdelta,dtt,ctxt,"vtxdelta");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_anim_klin_loc ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_anim_klin_loc") );
		map::rsc_collection_anim_klin_loc t;
		map::rsc_collection_anim_klin_loc::requirements req;
		req.keycnt = get_tag_req(dtt,"keycnt",ctxt);
		m.tag_add(t,req);
		writecontent_var(t.ort,dtt,ctxt,"ort");
		writecontent_var(t.samplingrate,dtt,ctxt,"samplingrate");
		writecontent_var(t.keycnt,dtt,ctxt,"keycnt");
		writecontent_var(t.keys,dtt,ctxt,"keys");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_shading_vs ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_shading_vs") );
		map::rsc_collection_shading_vs t;
		map::rsc_collection_shading_vs::requirements req;
		req.usagecount = get_tag_req(dtt,"usagecount",ctxt);
		req.data_size = get_tag_req(dtt,"data.size",ctxt);
		m.tag_add(t,req);
		writecontent_var(t.usagecount,dtt,ctxt,"usagecount");
		writecontent_var(t.usages,dtt,ctxt,"usages");
		writecontent_rec_blob(t.data,dtt,ctxt,"data");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_common_end ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_common_end") );
		map::rsc_common_end t;
		m.tag_add(t);
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_shading_constant ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_shading_constant") );
		map::rsc_collection_shading_constant t;
		m.tag_add(t);
		writecontent_var(t.namecrc,dtt,ctxt,"namecrc");
		writecontent_var(t.cclass,dtt,ctxt,"cclass");
		writecontent_var(t.ctype,dtt,ctxt,"ctype");
		writecontent_var(t.col,dtt,ctxt,"col");
		writecontent_var(t.row,dtt,ctxt,"row");
		writecontent_var(t.elt,dtt,ctxt,"elt");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_shading_rstate ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_shading_rstate") );
		map::rsc_collection_shading_rstate t;
		map::rsc_collection_shading_rstate::requirements req;
		req.regcnt = get_tag_req(dtt,"regcnt",ctxt);
		m.tag_add(t,req);
		writecontent_var(t.regcnt,dtt,ctxt,"regcnt");
		writecontent_var(t.registers,dtt,ctxt,"registers");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_bitmap_layer ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_bitmap_layer") );
		map::rsc_collection_bitmap_layer t;
		map::rsc_collection_bitmap_layer::requirements req;
		req.name_len = get_tag_req(dtt,"name.len",ctxt);
		req.size = get_tag_req(dtt,"size",ctxt);
		m.tag_add(t,req);
		writecontent_rec_string(t.name,dtt,ctxt,"name");
		writecontent_var(t.psm,dtt,ctxt,"psm");
		writecontent_var(t.size,dtt,ctxt,"size");
		writecontent_var(t.data,dtt,ctxt,"data");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_mesh_vbo ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_mesh_vbo") );
		map::rsc_collection_mesh_vbo t;
		map::rsc_collection_mesh_vbo::requirements req;
		req.data_size = get_tag_req(dtt,"data.size",ctxt);
		req.kick_size = get_tag_req(dtt,"kick.size",ctxt);
		m.tag_add(t,req);
		writecontent_var(t.vf,dtt,ctxt,"vf");
		writecontent_var(t.primtype,dtt,ctxt,"primtype");
		writecontent_var(t.dynamic,dtt,ctxt,"dynamic");
		writecontent_var(t.count,dtt,ctxt,"count");
		writecontent_rec_blob(t.data,dtt,ctxt,"data");
		writecontent_rec_bitmask(t.kick,dtt,ctxt,"kick");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


	void writecontent_tag_rsc_collection_litem_node ( map::base_map& m, IDatatree* dtt, map::context& ctxt )
	{
		SU_REQUIRE_OR_RETURN( ctxt.errcode==0 );
		Strcopy( ctxt.tagname, SU_VERBOSE_STR("rsc_collection_litem_node") );
		map::rsc_collection_litem_node t;
		map::rsc_collection_litem_node::requirements req;
		req.name_len = get_tag_req(dtt,"name.len",ctxt);
		req.note_len = get_tag_req(dtt,"note.len",ctxt);
		m.tag_add(t,req);
		writecontent_var(t.parentidx,dtt,ctxt,"parentidx");
		writecontent_rec_string(t.name,dtt,ctxt,"name");
		writecontent_rec_string(t.note,dtt,ctxt,"note");
		writecontent_var(t.hidden,dtt,ctxt,"hidden");
		writecontent_rec_matrix(t.trs,dtt,ctxt,"trs");
		writecontent_var(t.trsanimid,dtt,ctxt,"trsanimid");
		if( ctxt.errcode==0 ) ctxt.tagname[0]=0;
	}


}


// elements's code

int su::map::elements::create ( byte* p, uint in_count )
{
	util::Zero(*this);
	int s=0;
	s+=count.setup(p,s,8,1); count.set(in_count); count.ro=true; 
	s+=ids.setup(p,s,10,in_count); 
	return s;
}


int map::elements::load ( byte* p )
{
	util::Zero(*this);
	int s=0;
	s+=count.setup(p,s,8,1); 
	s+=ids.setup(p,s,10,count.get()); 
	return s;
}


// string's code

int su::map::string::create ( byte* p, uint in_len )
{
	util::Zero(*this);
	int s=0;
	s+=len.setup(p,s,10,1); len.set(in_len); len.ro=true; 
	s+=ub_align(p,s,0); s+=text.setup(p,s,8,in_len); 
	return s;
}


int map::string::load ( byte* p )
{
	util::Zero(*this);
	int s=0;
	s+=len.setup(p,s,10,1); 
	s+=ub_align(p,s,0); s+=text.setup(p,s,8,len.get()); 
	return s;
}


// quat's code

int su::map::quat::create ( byte* p )
{
	util::Zero(*this);
	int s=0;
	s+=x.setup(p,s,32,1); 
	s+=y.setup(p,s,32,1); 
	s+=z.setup(p,s,32,1); 
	s+=w.setup(p,s,32,1); 
	return s;
}


int map::quat::load ( byte* p )
{
	util::Zero(*this);
	int s=0;
	s+=x.setup(p,s,32,1); 
	s+=y.setup(p,s,32,1); 
	s+=z.setup(p,s,32,1); 
	s+=w.setup(p,s,32,1); 
	return s;
}


// vec3's code

int su::map::vec3::create ( byte* p )
{
	util::Zero(*this);
	int s=0;
	s+=x.setup(p,s,32,1); 
	s+=y.setup(p,s,32,1); 
	s+=z.setup(p,s,32,1); 
	return s;
}


int map::vec3::load ( byte* p )
{
	util::Zero(*this);
	int s=0;
	s+=x.setup(p,s,32,1); 
	s+=y.setup(p,s,32,1); 
	s+=z.setup(p,s,32,1); 
	return s;
}


// locations's code

int su::map::locations::create ( byte* p, uint in_count )
{
	util::Zero(*this);
	int s=0;
	s+=count.setup(p,s,8,1); count.set(in_count); count.ro=true; 
	s+=x.setup(p,s,32,in_count); 
	s+=y.setup(p,s,32,in_count); 
	s+=z.setup(p,s,32,in_count); 
	return s;
}


int map::locations::load ( byte* p )
{
	util::Zero(*this);
	int s=0;
	s+=count.setup(p,s,8,1); 
	s+=x.setup(p,s,32,count.get()); 
	s+=y.setup(p,s,32,count.get()); 
	s+=z.setup(p,s,32,count.get()); 
	return s;
}


// element's code

int su::map::element::create ( byte* p )
{
	util::Zero(*this);
	int s=0;
	s+=id.setup(p,s,10,1); 
	return s;
}


int map::element::load ( byte* p )
{
	util::Zero(*this);
	int s=0;
	s+=id.setup(p,s,10,1); 
	return s;
}


// matrix's code

int su::map::matrix::create ( byte* p )
{
	util::Zero(*this);
	int s=0;
	s+=coeff.setup(p,s,32,16); 
	return s;
}


int map::matrix::load ( byte* p )
{
	util::Zero(*this);
	int s=0;
	s+=coeff.setup(p,s,32,16); 
	return s;
}


// bitmask's code

int su::map::bitmask::create ( byte* p, uint in_size )
{
	util::Zero(*this);
	int s=0;
	s+=size.setup(p,s,32,1); size.set(in_size); size.ro=true; 
	s+=bits.setup(p,s,1,in_size); 
	return s;
}


int map::bitmask::load ( byte* p )
{
	util::Zero(*this);
	int s=0;
	s+=size.setup(p,s,32,1); 
	s+=bits.setup(p,s,1,size.get()); 
	return s;
}


// rscs's code

int su::map::rscs::create ( byte* p, uint in_count )
{
	util::Zero(*this);
	int s=0;
	s+=count.setup(p,s,8,1); count.set(in_count); count.ro=true; 
	s+=ids.setup(p,s,20,in_count); 
	return s;
}


int map::rscs::load ( byte* p )
{
	util::Zero(*this);
	int s=0;
	s+=count.setup(p,s,8,1); 
	s+=ids.setup(p,s,20,count.get()); 
	return s;
}


// blob's code

int su::map::blob::create ( byte* p, uint in_size )
{
	util::Zero(*this);
	int s=0;
	s+=size.setup(p,s,32,1); size.set(in_size); size.ro=true; 
	s+=ub_align(p,s,2); s+=bytes.setup(p,s,8,in_size); 
	return s;
}


int map::blob::load ( byte* p )
{
	util::Zero(*this);
	int s=0;
	s+=size.setup(p,s,32,1); 
	s+=ub_align(p,s,2); s+=bytes.setup(p,s,8,size.get()); 
	return s;
}


// vec4's code

int su::map::vec4::create ( byte* p )
{
	util::Zero(*this);
	int s=0;
	s+=x.setup(p,s,32,1); 
	s+=y.setup(p,s,32,1); 
	s+=z.setup(p,s,32,1); 
	s+=w.setup(p,s,32,1); 
	return s;
}


int map::vec4::load ( byte* p )
{
	util::Zero(*this);
	int s=0;
	s+=x.setup(p,s,32,1); 
	s+=y.setup(p,s,32,1); 
	s+=z.setup(p,s,32,1); 
	s+=w.setup(p,s,32,1); 
	return s;
}


// rsc's code

int su::map::rsc::create ( byte* p )
{
	util::Zero(*this);
	int s=0;
	s+=id.setup(p,s,20,1); 
	return s;
}


int map::rsc::load ( byte* p )
{
	util::Zero(*this);
	int s=0;
	s+=id.setup(p,s,20,1); 
	return s;
}


// strings's code

int su::map::strings::create ( byte* p, uint in_len )
{
	util::Zero(*this);
	int s=0;
	s+=count.setup(p,s,10,1); 
	s+=len.setup(p,s,10,1); len.set(in_len); len.ro=true; 
	s+=ub_align(p,s,0); s+=offsets.setup(p,s,16,1); 
	s+=ub_align(p,s,0); s+=texts.setup(p,s,8,in_len); 
	return s;
}


int map::strings::load ( byte* p )
{
	util::Zero(*this);
	int s=0;
	s+=count.setup(p,s,10,1); 
	s+=len.setup(p,s,10,1); 
	s+=ub_align(p,s,0); s+=offsets.setup(p,s,16,1); 
	s+=ub_align(p,s,0); s+=texts.setup(p,s,8,len.get()); 
	return s;
}


// box3's code

int su::map::box3::create ( byte* p )
{
	util::Zero(*this);
	int s=0;
	s+=center.setup(p,s,32,3); 
	s+=rotation.setup(p,s,32,4); 
	s+=length.setup(p,s,32,3); 
	return s;
}


int map::box3::load ( byte* p )
{
	util::Zero(*this);
	int s=0;
	s+=center.setup(p,s,32,3); 
	s+=rotation.setup(p,s,32,4); 
	s+=length.setup(p,s,32,3); 
	return s;
}


// location's code

int su::map::location::create ( byte* p )
{
	util::Zero(*this);
	int s=0;
	s+=x.setup(p,s,32,1); 
	s+=y.setup(p,s,32,1); 
	s+=z.setup(p,s,32,1); 
	return s;
}


int map::location::load ( byte* p )
{
	util::Zero(*this);
	int s=0;
	s+=x.setup(p,s,32,1); 
	s+=y.setup(p,s,32,1); 
	s+=z.setup(p,s,32,1); 
	return s;
}


// rsc_collection_anim_skelframe's code

int map::rsc_collection_anim_skelframe::create ( byte* p, requirements& r, bool forcelong, bool checkun )
{
	if( checkun ) {
		SU_ASSERT( !util::CheckUninitialized(r.bonecnt) );
		SU_ASSERT( !util::CheckUninitialized(r.framecnt) );
	}
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=freq.setup(p,s,8,1); 
	s+=bonecnt.setup(p,s,10,1); bonecnt.set(r.bonecnt); bonecnt.ro=true;
	s+=bonenames.setup(p,s,32,r.bonecnt); 
	s+=framecnt.setup(p,s,20,1); framecnt.set(r.framecnt); framecnt.ro=true;
	s+=ub_align(p,s,2); s+=frames.setup(p,s,32,r.bonecnt*4*r.framecnt); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,r,true,checkun); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_anim_skelframe::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=freq.setup(p,s,8,1); 
	s+=bonecnt.setup(p,s,10,1); 
	s+=bonenames.setup(p,s,32,bonecnt.get()); 
	s+=framecnt.setup(p,s,20,1); 
	s+=ub_align(p,s,2); s+=frames.setup(p,s,32,bonecnt.get()*4*framecnt.get()); 
	return s;
}


// rsc_collection_bitmap_dxmip's code

int map::rsc_collection_bitmap_dxmip::create ( byte* p, requirements& r, bool forcelong, bool checkun )
{
	if( checkun ) {
		SU_ASSERT( !util::CheckUninitialized(r.size) );
	}
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=format.setup(p,s,8,1); 
	s+=size.setup(p,s,30,1); size.set(r.size); size.ro=true;
	s+=ub_align(p,s,2); s+=data.setup(p,s,8,r.size); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,r,true,checkun); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_bitmap_dxmip::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=format.setup(p,s,8,1); 
	s+=size.setup(p,s,30,1); 
	s+=ub_align(p,s,2); s+=data.setup(p,s,8,size.get()); 
	return s;
}


// rsc_collection_litem_character's code

int map::rsc_collection_litem_character::create ( byte* p, requirements& r, bool forcelong, bool checkun )
{
	if( checkun ) {
		SU_ASSERT( !util::CheckUninitialized(r.name_len) );
		SU_ASSERT( !util::CheckUninitialized(r.note_len) );
	}
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=parentidx.setup(p,s,10,1); 
	s+=ub_align(p,s,0); s+=name.create(p+(s>>3),r.name_len); 
	s+=ub_align(p,s,0); s+=note.create(p+(s>>3),r.note_len); 
	s+=hidden.setup(p,s,1,1); 
	s+=ub_align(p,s,0); s+=trs.create(p+(s>>3)); 
	s+=trsanimid.setup(p,s,10,1); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,r,true,checkun); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_litem_character::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=parentidx.setup(p,s,10,1); 
	s+=ub_align(p,s,0); s+=name.load(p+(s>>3)); 
	s+=ub_align(p,s,0); s+=note.load(p+(s>>3)); 
	s+=hidden.setup(p,s,1,1); 
	s+=ub_align(p,s,0); s+=trs.load(p+(s>>3)); 
	s+=trsanimid.setup(p,s,10,1); 
	return s;
}


// rsc_collection_hotpoint's code

int map::rsc_collection_hotpoint::create ( byte* p, bool forcelong )
{
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=namecrc.setup(p,s,32,1); 
	s+=ub_align(p,s,0); s+=spot.create(p+(s>>3)); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,true); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_hotpoint::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=namecrc.setup(p,s,32,1); 
	s+=ub_align(p,s,0); s+=spot.load(p+(s>>3)); 
	return s;
}


// rsc_collection_hotspline's code

int map::rsc_collection_hotspline::create ( byte* p, bool forcelong )
{
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=namecrc.setup(p,s,32,1); 
	s+=ub_align(p,s,0); s+=start.create(p+(s>>3)); 
	s+=ub_align(p,s,0); s+=end.create(p+(s>>3)); 
	s+=ub_align(p,s,0); s+=intan.create(p+(s>>3)); 
	s+=ub_align(p,s,0); s+=outan.create(p+(s>>3)); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,true); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_hotspline::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=namecrc.setup(p,s,32,1); 
	s+=ub_align(p,s,0); s+=start.load(p+(s>>3)); 
	s+=ub_align(p,s,0); s+=end.load(p+(s>>3)); 
	s+=ub_align(p,s,0); s+=intan.load(p+(s>>3)); 
	s+=ub_align(p,s,0); s+=outan.load(p+(s>>3)); 
	return s;
}


// rsc_collection_litem_light's code

int map::rsc_collection_litem_light::create ( byte* p, requirements& r, bool forcelong, bool checkun )
{
	if( checkun ) {
		SU_ASSERT( !util::CheckUninitialized(r.name_len) );
		SU_ASSERT( !util::CheckUninitialized(r.note_len) );
	}
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=parentidx.setup(p,s,10,1); 
	s+=ub_align(p,s,0); s+=name.create(p+(s>>3),r.name_len); 
	s+=ub_align(p,s,0); s+=note.create(p+(s>>3),r.note_len); 
	s+=hidden.setup(p,s,1,1); 
	s+=ub_align(p,s,0); s+=trs.create(p+(s>>3)); 
	s+=trsanimid.setup(p,s,10,1); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,r,true,checkun); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_litem_light::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=parentidx.setup(p,s,10,1); 
	s+=ub_align(p,s,0); s+=name.load(p+(s>>3)); 
	s+=ub_align(p,s,0); s+=note.load(p+(s>>3)); 
	s+=hidden.setup(p,s,1,1); 
	s+=ub_align(p,s,0); s+=trs.load(p+(s>>3)); 
	s+=trsanimid.setup(p,s,10,1); 
	return s;
}


// rsc_collection_litem_camera's code

int map::rsc_collection_litem_camera::create ( byte* p, requirements& r, bool forcelong, bool checkun )
{
	if( checkun ) {
		SU_ASSERT( !util::CheckUninitialized(r.name_len) );
		SU_ASSERT( !util::CheckUninitialized(r.note_len) );
	}
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=parentidx.setup(p,s,10,1); 
	s+=ub_align(p,s,0); s+=name.create(p+(s>>3),r.name_len); 
	s+=ub_align(p,s,0); s+=note.create(p+(s>>3),r.note_len); 
	s+=hidden.setup(p,s,1,1); 
	s+=ub_align(p,s,0); s+=trs.create(p+(s>>3)); 
	s+=trsanimid.setup(p,s,10,1); 
	s+=fov.setup(p,s,32,1); 
	s+=fovanimid.setup(p,s,10,1); 
	s+=targetdist.setup(p,s,32,1); 
	s+=envrange.setup(p,s,32,2); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,r,true,checkun); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_litem_camera::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=parentidx.setup(p,s,10,1); 
	s+=ub_align(p,s,0); s+=name.load(p+(s>>3)); 
	s+=ub_align(p,s,0); s+=note.load(p+(s>>3)); 
	s+=hidden.setup(p,s,1,1); 
	s+=ub_align(p,s,0); s+=trs.load(p+(s>>3)); 
	s+=trsanimid.setup(p,s,10,1); 
	s+=fov.setup(p,s,32,1); 
	s+=fovanimid.setup(p,s,10,1); 
	s+=targetdist.setup(p,s,32,1); 
	s+=envrange.setup(p,s,32,2); 
	return s;
}


// rsc_collection_litem_bone's code

int map::rsc_collection_litem_bone::create ( byte* p, requirements& r, bool forcelong, bool checkun )
{
	if( checkun ) {
		SU_ASSERT( !util::CheckUninitialized(r.name_len) );
		SU_ASSERT( !util::CheckUninitialized(r.note_len) );
	}
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=parentidx.setup(p,s,10,1); 
	s+=ub_align(p,s,0); s+=name.create(p+(s>>3),r.name_len); 
	s+=ub_align(p,s,0); s+=note.create(p+(s>>3),r.note_len); 
	s+=hidden.setup(p,s,1,1); 
	s+=ub_align(p,s,0); s+=trs.create(p+(s>>3)); 
	s+=trsanimid.setup(p,s,10,1); 
	s+=length.setup(p,s,32,1); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,r,true,checkun); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_litem_bone::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=parentidx.setup(p,s,10,1); 
	s+=ub_align(p,s,0); s+=name.load(p+(s>>3)); 
	s+=ub_align(p,s,0); s+=note.load(p+(s>>3)); 
	s+=hidden.setup(p,s,1,1); 
	s+=ub_align(p,s,0); s+=trs.load(p+(s>>3)); 
	s+=trsanimid.setup(p,s,10,1); 
	s+=length.setup(p,s,32,1); 
	return s;
}


// rsc_userdata_content's code

int map::rsc_userdata_content::create ( byte* p, requirements& r, bool forcelong, bool checkun )
{
	if( checkun ) {
		SU_ASSERT( !util::CheckUninitialized(r.label_len) );
		SU_ASSERT( !util::CheckUninitialized(r.sourcefile_len) );
		SU_ASSERT( !util::CheckUninitialized(r.data_size) );
	}
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=ub_align(p,s,0); s+=label.create(p+(s>>3),r.label_len); 
	s+=ub_align(p,s,0); s+=sourcefile.create(p+(s>>3),r.sourcefile_len); 
	s+=ub_align(p,s,0); s+=data.create(p+(s>>3),r.data_size); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,r,true,checkun); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_userdata_content::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=ub_align(p,s,0); s+=label.load(p+(s>>3)); 
	s+=ub_align(p,s,0); s+=sourcefile.load(p+(s>>3)); 
	s+=ub_align(p,s,0); s+=data.load(p+(s>>3)); 
	return s;
}


// rsc_collection_hotsphere's code

int map::rsc_collection_hotsphere::create ( byte* p, bool forcelong )
{
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=namecrc.setup(p,s,32,1); 
	s+=ub_align(p,s,0); s+=center.create(p+(s>>3)); 
	s+=radius.setup(p,s,32,1); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,true); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_hotsphere::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=namecrc.setup(p,s,32,1); 
	s+=ub_align(p,s,0); s+=center.load(p+(s>>3)); 
	s+=radius.setup(p,s,32,1); 
	return s;
}


// rsc_collection_shading_technique's code

int map::rsc_collection_shading_technique::create ( byte* p, requirements& r, bool forcelong, bool checkun )
{
	if( checkun ) {
		SU_ASSERT( !util::CheckUninitialized(r.name_len) );
		SU_ASSERT( !util::CheckUninitialized(r.note_len) );
	}
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=ub_align(p,s,0); s+=name.create(p+(s>>3),r.name_len); 
	s+=namecrc.setup(p,s,32,1); 
	s+=ub_align(p,s,0); s+=note.create(p+(s>>3),r.note_len); 
	s+=passcnt.setup(p,s,6,1); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,r,true,checkun); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_shading_technique::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=ub_align(p,s,0); s+=name.load(p+(s>>3)); 
	s+=namecrc.setup(p,s,32,1); 
	s+=ub_align(p,s,0); s+=note.load(p+(s>>3)); 
	s+=passcnt.setup(p,s,6,1); 
	return s;
}


// rsc_collection_bitmap_s3mip's code

int map::rsc_collection_bitmap_s3mip::create ( byte* p, requirements& r, bool forcelong, bool checkun )
{
	if( checkun ) {
		SU_ASSERT( !util::CheckUninitialized(r.size) );
	}
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=format.setup(p,s,2,1); 
	s+=size.setup(p,s,30,1); size.set(r.size); size.ro=true;
	s+=ub_align(p,s,2); s+=data.setup(p,s,8,r.size); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,r,true,checkun); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_bitmap_s3mip::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=format.setup(p,s,2,1); 
	s+=size.setup(p,s,30,1); 
	s+=ub_align(p,s,2); s+=data.setup(p,s,8,size.get()); 
	return s;
}


// rsc_collection_skeleton's code

int map::rsc_collection_skeleton::create ( byte* p, requirements& r, bool forcelong, bool checkun )
{
	if( checkun ) {
		SU_ASSERT( !util::CheckUninitialized(r.note_len) );
	}
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=ub_align(p,s,0); s+=bbox.create(p+(s>>3)); 
	s+=ub_align(p,s,0); s+=note.create(p+(s>>3),r.note_len); 
	s+=bonecnt.setup(p,s,16,1); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,r,true,checkun); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_skeleton::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=ub_align(p,s,0); s+=bbox.load(p+(s>>3)); 
	s+=ub_align(p,s,0); s+=note.load(p+(s>>3)); 
	s+=bonecnt.setup(p,s,16,1); 
	return s;
}


// rsc_collection_mesh_blendprocess's code

int map::rsc_collection_mesh_blendprocess::create ( byte* p, requirements& r, bool forcelong, bool checkun )
{
	if( checkun ) {
		SU_ASSERT( !util::CheckUninitialized(r.vcount) );
		SU_ASSERT( !util::CheckUninitialized(r.vstride) );
		SU_ASSERT( !util::CheckUninitialized(r.bcount) );
	}
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=vbidx.setup(p,s,10,1); 
	s+=vcount.setup(p,s,20,1); vcount.set(r.vcount); vcount.ro=true;
	s+=vstride.setup(p,s,4,1); vstride.set(r.vstride); vstride.ro=true;
	s+=ub_align(p,s,2); s+=vertices.setup(p,s,32,r.vcount*r.vstride); 
	s+=bcount.setup(p,s,10,1); bcount.set(r.bcount); bcount.ro=true;
	s+=bones.setup(p,s,32,r.bcount); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,r,true,checkun); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_mesh_blendprocess::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=vbidx.setup(p,s,10,1); 
	s+=vcount.setup(p,s,20,1); 
	s+=vstride.setup(p,s,4,1); 
	s+=ub_align(p,s,2); s+=vertices.setup(p,s,32,vcount.get()*vstride.get()); 
	s+=bcount.setup(p,s,10,1); 
	s+=bones.setup(p,s,32,bcount.get()); 
	return s;
}


// rsc_collection_bitmap_drivermip's code

int map::rsc_collection_bitmap_drivermip::create ( byte* p, requirements& r, bool forcelong, bool checkun )
{
	if( checkun ) {
		SU_ASSERT( !util::CheckUninitialized(r.size) );
	}
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=format.setup(p,s,4,1); 
	s+=size.setup(p,s,30,1); size.set(r.size); size.ro=true;
	s+=ub_align(p,s,2); s+=data.setup(p,s,8,r.size); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,r,true,checkun); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_bitmap_drivermip::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=format.setup(p,s,4,1); 
	s+=size.setup(p,s,30,1); 
	s+=ub_align(p,s,2); s+=data.setup(p,s,8,size.get()); 
	return s;
}


// rsc_collection_litem_geometry's code

int map::rsc_collection_litem_geometry::create ( byte* p, requirements& r, bool forcelong, bool checkun )
{
	if( checkun ) {
		SU_ASSERT( !util::CheckUninitialized(r.name_len) );
		SU_ASSERT( !util::CheckUninitialized(r.note_len) );
	}
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=parentidx.setup(p,s,10,1); 
	s+=ub_align(p,s,0); s+=name.create(p+(s>>3),r.name_len); 
	s+=ub_align(p,s,0); s+=note.create(p+(s>>3),r.note_len); 
	s+=hidden.setup(p,s,1,1); 
	s+=ub_align(p,s,0); s+=trs.create(p+(s>>3)); 
	s+=trsanimid.setup(p,s,10,1); 
	s+=ub_align(p,s,0); s+=offset.create(p+(s>>3)); 
	s+=meshid.setup(p,s,10,1); 
	s+=color.setup(p,s,8,4); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,r,true,checkun); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_litem_geometry::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=parentidx.setup(p,s,10,1); 
	s+=ub_align(p,s,0); s+=name.load(p+(s>>3)); 
	s+=ub_align(p,s,0); s+=note.load(p+(s>>3)); 
	s+=hidden.setup(p,s,1,1); 
	s+=ub_align(p,s,0); s+=trs.load(p+(s>>3)); 
	s+=trsanimid.setup(p,s,10,1); 
	s+=ub_align(p,s,0); s+=offset.load(p+(s>>3)); 
	s+=meshid.setup(p,s,10,1); 
	s+=color.setup(p,s,8,4); 
	return s;
}


// rsc_collection_anim_klin_scl's code

int map::rsc_collection_anim_klin_scl::create ( byte* p, requirements& r, bool forcelong, bool checkun )
{
	if( checkun ) {
		SU_ASSERT( !util::CheckUninitialized(r.keycnt) );
	}
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=ort.setup(p,s,3,2); 
	s+=samplingrate.setup(p,s,10,1); 
	s+=keycnt.setup(p,s,16,1); keycnt.set(r.keycnt); keycnt.ro=true;
	s+=keys.setup(p,s,32,r.keycnt*4); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,r,true,checkun); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_anim_klin_scl::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=ort.setup(p,s,3,2); 
	s+=samplingrate.setup(p,s,10,1); 
	s+=keycnt.setup(p,s,16,1); 
	s+=keys.setup(p,s,32,keycnt.get()*4); 
	return s;
}


// rsc_collection_anim's code

int map::rsc_collection_anim::create ( byte* p, bool forcelong )
{
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=ub_align(p,s,0); s+=bbox.create(p+(s>>3)); 
	s+=timerange.setup(p,s,32,2); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,true); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_anim::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=ub_align(p,s,0); s+=bbox.load(p+(s>>3)); 
	s+=timerange.setup(p,s,32,2); 
	return s;
}


// rsc_collection_bitmap_glmip's code

int map::rsc_collection_bitmap_glmip::create ( byte* p, requirements& r, bool forcelong, bool checkun )
{
	if( checkun ) {
		SU_ASSERT( !util::CheckUninitialized(r.size) );
	}
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=format.setup(p,s,32,1); 
	s+=type.setup(p,s,32,1); 
	s+=size.setup(p,s,30,1); size.set(r.size); size.ro=true;
	s+=ub_align(p,s,2); s+=data.setup(p,s,8,r.size); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,r,true,checkun); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_bitmap_glmip::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=format.setup(p,s,32,1); 
	s+=type.setup(p,s,32,1); 
	s+=size.setup(p,s,30,1); 
	s+=ub_align(p,s,2); s+=data.setup(p,s,8,size.get()); 
	return s;
}


// rsc_collection_anim_klin_rot's code

int map::rsc_collection_anim_klin_rot::create ( byte* p, requirements& r, bool forcelong, bool checkun )
{
	if( checkun ) {
		SU_ASSERT( !util::CheckUninitialized(r.keycnt) );
	}
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=ort.setup(p,s,3,2); 
	s+=samplingrate.setup(p,s,10,1); 
	s+=keycnt.setup(p,s,16,1); keycnt.set(r.keycnt); keycnt.ro=true;
	s+=keys.setup(p,s,32,r.keycnt*5); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,r,true,checkun); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_anim_klin_rot::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=ort.setup(p,s,3,2); 
	s+=samplingrate.setup(p,s,10,1); 
	s+=keycnt.setup(p,s,16,1); 
	s+=keys.setup(p,s,32,keycnt.get()*5); 
	return s;
}


// rsc_collection_shading_pass's code

int map::rsc_collection_shading_pass::create ( byte* p, bool forcelong )
{
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=psidx.setup(p,s,10,1); 
	s+=vsidx.setup(p,s,10,1); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,true); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_shading_pass::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=psidx.setup(p,s,10,1); 
	s+=vsidx.setup(p,s,10,1); 
	return s;
}


// rsc_collection_skeleton_bone's code

int map::rsc_collection_skeleton_bone::create ( byte* p, requirements& r, bool forcelong, bool checkun )
{
	if( checkun ) {
		SU_ASSERT( !util::CheckUninitialized(r.name_len) );
		SU_ASSERT( !util::CheckUninitialized(r.note_len) );
	}
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=ub_align(p,s,0); s+=name.create(p+(s>>3),r.name_len); 
	s+=namecrc.setup(p,s,32,1); 
	s+=parentidx.setup(p,s,10,1); 
	s+=ub_align(p,s,0); s+=note.create(p+(s>>3),r.note_len); 
	s+=pose.setup(p,s,32,5); 
	s+=ub_align(p,s,0); s+=tobonetr.create(p+(s>>3)); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,r,true,checkun); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_skeleton_bone::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=ub_align(p,s,0); s+=name.load(p+(s>>3)); 
	s+=namecrc.setup(p,s,32,1); 
	s+=parentidx.setup(p,s,10,1); 
	s+=ub_align(p,s,0); s+=note.load(p+(s>>3)); 
	s+=pose.setup(p,s,32,5); 
	s+=ub_align(p,s,0); s+=tobonetr.load(p+(s>>3)); 
	return s;
}


// rsc_collection_anim_morphframe's code

int map::rsc_collection_anim_morphframe::create ( byte* p, requirements& r, bool forcelong, bool checkun )
{
	if( checkun ) {
		SU_ASSERT( !util::CheckUninitialized(r.targetcnt) );
		SU_ASSERT( !util::CheckUninitialized(r.framecnt) );
	}
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=freq.setup(p,s,8,1); 
	s+=targetcnt.setup(p,s,10,1); targetcnt.set(r.targetcnt); targetcnt.ro=true;
	s+=tnames.setup(p,s,32,r.targetcnt); 
	s+=tdownlim.setup(p,s,32,r.targetcnt); 
	s+=tuplim.setup(p,s,32,r.targetcnt); 
	s+=framecnt.setup(p,s,20,1); framecnt.set(r.framecnt); framecnt.ro=true;
	s+=ub_align(p,s,2); s+=frames.setup(p,s,32,r.targetcnt*1*r.framecnt); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,r,true,checkun); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_anim_morphframe::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=freq.setup(p,s,8,1); 
	s+=targetcnt.setup(p,s,10,1); 
	s+=tnames.setup(p,s,32,targetcnt.get()); 
	s+=tdownlim.setup(p,s,32,targetcnt.get()); 
	s+=tuplim.setup(p,s,32,targetcnt.get()); 
	s+=framecnt.setup(p,s,20,1); 
	s+=ub_align(p,s,2); s+=frames.setup(p,s,32,targetcnt.get()*1*framecnt.get()); 
	return s;
}


// rsc_collection_bitmap_pvrmip's code

int map::rsc_collection_bitmap_pvrmip::create ( byte* p, requirements& r, bool forcelong, bool checkun )
{
	if( checkun ) {
		SU_ASSERT( !util::CheckUninitialized(r.size) );
	}
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=format.setup(p,s,1,1); 
	s+=size.setup(p,s,30,1); size.set(r.size); size.ro=true;
	s+=ub_align(p,s,2); s+=data.setup(p,s,8,r.size); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,r,true,checkun); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_bitmap_pvrmip::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=format.setup(p,s,1,1); 
	s+=size.setup(p,s,30,1); 
	s+=ub_align(p,s,2); s+=data.setup(p,s,8,size.get()); 
	return s;
}


// rsc_collection_sourcefile's code

int map::rsc_collection_sourcefile::create ( byte* p, requirements& r, bool forcelong, bool checkun )
{
	if( checkun ) {
		SU_ASSERT( !util::CheckUninitialized(r.filename_len) );
	}
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=ub_align(p,s,0); s+=filename.create(p+(s>>3),r.filename_len); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,r,true,checkun); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_sourcefile::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=ub_align(p,s,0); s+=filename.load(p+(s>>3)); 
	return s;
}


// rsc_collection_hotbox's code

int map::rsc_collection_hotbox::create ( byte* p, bool forcelong )
{
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=namecrc.setup(p,s,32,1); 
	s+=ub_align(p,s,0); s+=box.create(p+(s>>3)); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,true); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_hotbox::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=namecrc.setup(p,s,32,1); 
	s+=ub_align(p,s,0); s+=box.load(p+(s>>3)); 
	return s;
}


// rsc_collection_mesh_blendpass's code

int map::rsc_collection_mesh_blendpass::create ( byte* p, requirements& r, bool forcelong, bool checkun )
{
	if( checkun ) {
		SU_ASSERT( !util::CheckUninitialized(r.arity) );
		SU_ASSERT( !util::CheckUninitialized(r.count) );
	}
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=arity.setup(p,s,3,1); arity.set(r.arity); arity.ro=true;
	s+=count.setup(p,s,20,1); count.set(r.count); count.ro=true;
	s+=ub_align(p,s,2); s+=bw.setup(p,s,32,r.arity); 
	s+=ub_align(p,s,1); s+=bidx.setup(p,s,16,r.count*r.arity); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,r,true,checkun); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_mesh_blendpass::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=arity.setup(p,s,3,1); 
	s+=count.setup(p,s,20,1); 
	s+=ub_align(p,s,2); s+=bw.setup(p,s,32,arity.get()); 
	s+=ub_align(p,s,1); s+=bidx.setup(p,s,16,count.get()*arity.get()); 
	return s;
}


// rsc_collection_list's code

int map::rsc_collection_list::create ( byte* p, requirements& r, bool forcelong, bool checkun )
{
	if( checkun ) {
		SU_ASSERT( !util::CheckUninitialized(r.name_len) );
	}
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=ub_align(p,s,0); s+=name.create(p+(s>>3),r.name_len); 
	s+=count.setup(p,s,10,1); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,r,true,checkun); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_list::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=ub_align(p,s,0); s+=name.load(p+(s>>3)); 
	s+=count.setup(p,s,10,1); 
	return s;
}


// rsc_collection_hotsegment's code

int map::rsc_collection_hotsegment::create ( byte* p, bool forcelong )
{
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=namecrc.setup(p,s,32,1); 
	s+=ub_align(p,s,0); s+=start.create(p+(s>>3)); 
	s+=ub_align(p,s,0); s+=end.create(p+(s>>3)); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,true); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_hotsegment::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=namecrc.setup(p,s,32,1); 
	s+=ub_align(p,s,0); s+=start.load(p+(s>>3)); 
	s+=ub_align(p,s,0); s+=end.load(p+(s>>3)); 
	return s;
}


// rsc_collection_hotcloud's code

int map::rsc_collection_hotcloud::create ( byte* p, requirements& r, bool forcelong, bool checkun )
{
	if( checkun ) {
		SU_ASSERT( !util::CheckUninitialized(r.spots_count) );
	}
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=namecrc.setup(p,s,32,1); 
	s+=ub_align(p,s,0); s+=spots.create(p+(s>>3),r.spots_count); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,r,true,checkun); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_hotcloud::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=namecrc.setup(p,s,32,1); 
	s+=ub_align(p,s,0); s+=spots.load(p+(s>>3)); 
	return s;
}


// rsc_collection_mesh's code

int map::rsc_collection_mesh::create ( byte* p, bool forcelong )
{
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=ub_align(p,s,0); s+=bbox.create(p+(s>>3)); 
	s+=skeletonid.setup(p,s,10,1); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,true); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_mesh::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=ub_align(p,s,0); s+=bbox.load(p+(s>>3)); 
	s+=skeletonid.setup(p,s,10,1); 
	return s;
}


// rsc_collection_litem_helper's code

int map::rsc_collection_litem_helper::create ( byte* p, requirements& r, bool forcelong, bool checkun )
{
	if( checkun ) {
		SU_ASSERT( !util::CheckUninitialized(r.name_len) );
		SU_ASSERT( !util::CheckUninitialized(r.note_len) );
	}
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=parentidx.setup(p,s,10,1); 
	s+=ub_align(p,s,0); s+=name.create(p+(s>>3),r.name_len); 
	s+=ub_align(p,s,0); s+=note.create(p+(s>>3),r.note_len); 
	s+=hidden.setup(p,s,1,1); 
	s+=ub_align(p,s,0); s+=trs.create(p+(s>>3)); 
	s+=trsanimid.setup(p,s,10,1); 
	s+=width.setup(p,s,32,1); 
	s+=height.setup(p,s,32,1); 
	s+=depth.setup(p,s,32,1); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,r,true,checkun); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_litem_helper::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=parentidx.setup(p,s,10,1); 
	s+=ub_align(p,s,0); s+=name.load(p+(s>>3)); 
	s+=ub_align(p,s,0); s+=note.load(p+(s>>3)); 
	s+=hidden.setup(p,s,1,1); 
	s+=ub_align(p,s,0); s+=trs.load(p+(s>>3)); 
	s+=trsanimid.setup(p,s,10,1); 
	s+=width.setup(p,s,32,1); 
	s+=height.setup(p,s,32,1); 
	s+=depth.setup(p,s,32,1); 
	return s;
}


// rsc_collection_litem_export's code

int map::rsc_collection_litem_export::create ( byte* p, requirements& r, bool forcelong, bool checkun )
{
	if( checkun ) {
		SU_ASSERT( !util::CheckUninitialized(r.name_len) );
	}
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=objectid.setup(p,s,10,1); 
	s+=ub_align(p,s,0); s+=name.create(p+(s>>3),r.name_len); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,r,true,checkun); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_litem_export::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=objectid.setup(p,s,10,1); 
	s+=ub_align(p,s,0); s+=name.load(p+(s>>3)); 
	return s;
}


// rsc_collection_mesh_surface's code

int map::rsc_collection_mesh_surface::create ( byte* p, requirements& r, bool forcelong, bool checkun )
{
	if( checkun ) {
		SU_ASSERT( !util::CheckUninitialized(r.shdparams_len) );
		SU_ASSERT( !util::CheckUninitialized(r.texids_count) );
	}
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=vboidx.setup(p,s,6,1); 
	s+=effectid.setup(p,s,10,1); 
	s+=techniqueidx.setup(p,s,32,1); 
	s+=ub_align(p,s,0); s+=shdparams.create(p+(s>>3),r.shdparams_len); 
	s+=ub_align(p,s,0); s+=texids.create(p+(s>>3),r.texids_count); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,r,true,checkun); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_mesh_surface::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=vboidx.setup(p,s,6,1); 
	s+=effectid.setup(p,s,10,1); 
	s+=techniqueidx.setup(p,s,32,1); 
	s+=ub_align(p,s,0); s+=shdparams.load(p+(s>>3)); 
	s+=ub_align(p,s,0); s+=texids.load(p+(s>>3)); 
	return s;
}


// rsc_collection_anim_klin_float's code

int map::rsc_collection_anim_klin_float::create ( byte* p, requirements& r, bool forcelong, bool checkun )
{
	if( checkun ) {
		SU_ASSERT( !util::CheckUninitialized(r.keycnt) );
	}
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=ort.setup(p,s,3,2); 
	s+=samplingrate.setup(p,s,10,1); 
	s+=keycnt.setup(p,s,16,1); keycnt.set(r.keycnt); keycnt.ro=true;
	s+=keys.setup(p,s,32,r.keycnt*2); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,r,true,checkun); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_anim_klin_float::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=ort.setup(p,s,3,2); 
	s+=samplingrate.setup(p,s,10,1); 
	s+=keycnt.setup(p,s,16,1); 
	s+=keys.setup(p,s,32,keycnt.get()*2); 
	return s;
}


// rsc_collection_shading_effect's code

int map::rsc_collection_shading_effect::create ( byte* p, requirements& r, bool forcelong, bool checkun )
{
	if( checkun ) {
		SU_ASSERT( !util::CheckUninitialized(r.name_len) );
		SU_ASSERT( !util::CheckUninitialized(r.note_len) );
	}
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=ub_align(p,s,0); s+=name.create(p+(s>>3),r.name_len); 
	s+=ub_align(p,s,0); s+=note.create(p+(s>>3),r.note_len); 
	s+=techcnt.setup(p,s,6,1); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,r,true,checkun); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_shading_effect::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=ub_align(p,s,0); s+=name.load(p+(s>>3)); 
	s+=ub_align(p,s,0); s+=note.load(p+(s>>3)); 
	s+=techcnt.setup(p,s,6,1); 
	return s;
}


// rsc_collection_define's code

int map::rsc_collection_define::create ( byte* p, bool forcelong )
{
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=id.setup(p,s,10,1); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,true); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_define::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=id.setup(p,s,10,1); 
	return s;
}


// rsc_collection_anim_note's code

int map::rsc_collection_anim_note::create ( byte* p, requirements& r, bool forcelong, bool checkun )
{
	if( checkun ) {
		SU_ASSERT( !util::CheckUninitialized(r.keycnt) );
		SU_ASSERT( !util::CheckUninitialized(r.notes_len) );
	}
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=keycnt.setup(p,s,16,1); keycnt.set(r.keycnt); keycnt.ro=true;
	s+=keys.setup(p,s,32,r.keycnt); 
	s+=ub_align(p,s,0); s+=notes.create(p+(s>>3),r.notes_len); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,r,true,checkun); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_anim_note::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=keycnt.setup(p,s,16,1); 
	s+=keys.setup(p,s,32,keycnt.get()); 
	s+=ub_align(p,s,0); s+=notes.load(p+(s>>3)); 
	return s;
}


// rsc_collection_bitmap's code

int map::rsc_collection_bitmap::create ( byte* p, bool forcelong )
{
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=width.setup(p,s,12,1); 
	s+=height.setup(p,s,12,1); 
	s+=wpad.setup(p,s,8,1); 
	s+=hpad.setup(p,s,8,1); 
	s+=astatus.setup(p,s,2,1); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,true); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_bitmap::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=width.setup(p,s,12,1); 
	s+=height.setup(p,s,12,1); 
	s+=wpad.setup(p,s,8,1); 
	s+=hpad.setup(p,s,8,1); 
	s+=astatus.setup(p,s,2,1); 
	return s;
}


// rsc_collection_shading_ps's code

int map::rsc_collection_shading_ps::create ( byte* p, requirements& r, bool forcelong, bool checkun )
{
	if( checkun ) {
		SU_ASSERT( !util::CheckUninitialized(r.data_size) );
	}
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=ub_align(p,s,0); s+=data.create(p+(s>>3),r.data_size); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,r,true,checkun); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_shading_ps::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=ub_align(p,s,0); s+=data.load(p+(s>>3)); 
	return s;
}


// rsc_collection_shading_gs's code

int map::rsc_collection_shading_gs::create ( byte* p, requirements& r, bool forcelong, bool checkun )
{
	if( checkun ) {
		SU_ASSERT( !util::CheckUninitialized(r.data_size) );
	}
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=ub_align(p,s,0); s+=data.create(p+(s>>3),r.data_size); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,r,true,checkun); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_shading_gs::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=ub_align(p,s,0); s+=data.load(p+(s>>3)); 
	return s;
}


// rsc_collection_morph_target's code

int map::rsc_collection_morph_target::create ( byte* p, requirements& r, bool forcelong, bool checkun )
{
	if( checkun ) {
		SU_ASSERT( !util::CheckUninitialized(r.name_len) );
		SU_ASSERT( !util::CheckUninitialized(r.vtxcnt) );
	}
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=ub_align(p,s,0); s+=name.create(p+(s>>3),r.name_len); 
	s+=namecrc.setup(p,s,32,1); 
	s+=vtxcnt.setup(p,s,20,1); vtxcnt.set(r.vtxcnt); vtxcnt.ro=true;
	s+=ub_align(p,s,2); s+=vtxidx.setup(p,s,32,r.vtxcnt); 
	s+=ub_align(p,s,2); s+=vtxdelta.setup(p,s,32,r.vtxcnt); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,r,true,checkun); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_morph_target::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=ub_align(p,s,0); s+=name.load(p+(s>>3)); 
	s+=namecrc.setup(p,s,32,1); 
	s+=vtxcnt.setup(p,s,20,1); 
	s+=ub_align(p,s,2); s+=vtxidx.setup(p,s,32,vtxcnt.get()); 
	s+=ub_align(p,s,2); s+=vtxdelta.setup(p,s,32,vtxcnt.get()); 
	return s;
}


// rsc_collection_anim_klin_loc's code

int map::rsc_collection_anim_klin_loc::create ( byte* p, requirements& r, bool forcelong, bool checkun )
{
	if( checkun ) {
		SU_ASSERT( !util::CheckUninitialized(r.keycnt) );
	}
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=ort.setup(p,s,3,2); 
	s+=samplingrate.setup(p,s,10,1); 
	s+=keycnt.setup(p,s,16,1); keycnt.set(r.keycnt); keycnt.ro=true;
	s+=keys.setup(p,s,32,r.keycnt*4); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,r,true,checkun); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_anim_klin_loc::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=ort.setup(p,s,3,2); 
	s+=samplingrate.setup(p,s,10,1); 
	s+=keycnt.setup(p,s,16,1); 
	s+=keys.setup(p,s,32,keycnt.get()*4); 
	return s;
}


// rsc_collection_shading_vs's code

int map::rsc_collection_shading_vs::create ( byte* p, requirements& r, bool forcelong, bool checkun )
{
	if( checkun ) {
		SU_ASSERT( !util::CheckUninitialized(r.usagecount) );
		SU_ASSERT( !util::CheckUninitialized(r.data_size) );
	}
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=usagecount.setup(p,s,4,1); usagecount.set(r.usagecount); usagecount.ro=true;
	s+=usages.setup(p,s,4,r.usagecount); 
	s+=ub_align(p,s,0); s+=data.create(p+(s>>3),r.data_size); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,r,true,checkun); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_shading_vs::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=usagecount.setup(p,s,4,1); 
	s+=usages.setup(p,s,4,usagecount.get()); 
	s+=ub_align(p,s,0); s+=data.load(p+(s>>3)); 
	return s;
}


// rsc_common_end's code

int map::rsc_common_end::create ( byte* p, bool forcelong )
{
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,true); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_common_end::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	return s;
}


// rsc_collection_shading_constant's code

int map::rsc_collection_shading_constant::create ( byte* p, bool forcelong )
{
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=namecrc.setup(p,s,32,1); 
	s+=cclass.setup(p,s,4,1); 
	s+=ctype.setup(p,s,4,1); 
	s+=col.setup(p,s,3,1); 
	s+=row.setup(p,s,3,1); 
	s+=elt.setup(p,s,5,1); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,true); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_shading_constant::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=namecrc.setup(p,s,32,1); 
	s+=cclass.setup(p,s,4,1); 
	s+=ctype.setup(p,s,4,1); 
	s+=col.setup(p,s,3,1); 
	s+=row.setup(p,s,3,1); 
	s+=elt.setup(p,s,5,1); 
	return s;
}


// rsc_collection_shading_rstate's code

int map::rsc_collection_shading_rstate::create ( byte* p, requirements& r, bool forcelong, bool checkun )
{
	if( checkun ) {
		SU_ASSERT( !util::CheckUninitialized(r.regcnt) );
	}
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=regcnt.setup(p,s,6,1); regcnt.set(r.regcnt); regcnt.ro=true;
	s+=ub_align(p,s,0); s+=registers.setup(p,s,32,r.regcnt); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,r,true,checkun); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_shading_rstate::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=regcnt.setup(p,s,6,1); 
	s+=ub_align(p,s,0); s+=registers.setup(p,s,32,regcnt.get()); 
	return s;
}


// rsc_collection_bitmap_layer's code

int map::rsc_collection_bitmap_layer::create ( byte* p, requirements& r, bool forcelong, bool checkun )
{
	if( checkun ) {
		SU_ASSERT( !util::CheckUninitialized(r.name_len) );
		SU_ASSERT( !util::CheckUninitialized(r.size) );
	}
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=ub_align(p,s,0); s+=name.create(p+(s>>3),r.name_len); 
	s+=psm.setup(p,s,4,1); 
	s+=size.setup(p,s,30,1); size.set(r.size); size.ro=true;
	s+=ub_align(p,s,2); s+=data.setup(p,s,8,r.size); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,r,true,checkun); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_bitmap_layer::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=ub_align(p,s,0); s+=name.load(p+(s>>3)); 
	s+=psm.setup(p,s,4,1); 
	s+=size.setup(p,s,30,1); 
	s+=ub_align(p,s,2); s+=data.setup(p,s,8,size.get()); 
	return s;
}


// rsc_collection_mesh_vbo's code

int map::rsc_collection_mesh_vbo::create ( byte* p, requirements& r, bool forcelong, bool checkun )
{
	if( checkun ) {
		SU_ASSERT( !util::CheckUninitialized(r.data_size) );
		SU_ASSERT( !util::CheckUninitialized(r.kick_size) );
	}
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=vf.setup(p,s,9,1); 
	s+=primtype.setup(p,s,2,1); 
	s+=dynamic.setup(p,s,1,1); 
	s+=count.setup(p,s,16,1); 
	s+=ub_align(p,s,0); s+=data.create(p+(s>>3),r.data_size); 
	s+=ub_align(p,s,0); s+=kick.create(p+(s>>3),r.kick_size); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,r,true,checkun); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_mesh_vbo::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=vf.setup(p,s,9,1); 
	s+=primtype.setup(p,s,2,1); 
	s+=dynamic.setup(p,s,1,1); 
	s+=count.setup(p,s,16,1); 
	s+=ub_align(p,s,0); s+=data.load(p+(s>>3)); 
	s+=ub_align(p,s,0); s+=kick.load(p+(s>>3)); 
	return s;
}


// rsc_collection_litem_node's code

int map::rsc_collection_litem_node::create ( byte* p, requirements& r, bool forcelong, bool checkun )
{
	if( checkun ) {
		SU_ASSERT( !util::CheckUninitialized(r.name_len) );
		SU_ASSERT( !util::CheckUninitialized(r.note_len) );
	}
	util::Zero(*this);
	int s=base_tag::create(p,forcelong); code.set(CODE);
	s+=parentidx.setup(p,s,10,1); 
	s+=ub_align(p,s,0); s+=name.create(p+(s>>3),r.name_len); 
	s+=ub_align(p,s,0); s+=note.create(p+(s>>3),r.note_len); 
	s+=hidden.setup(p,s,1,1); 
	s+=ub_align(p,s,0); s+=trs.create(p+(s>>3)); 
	s+=trsanimid.setup(p,s,10,1); 
	if(forcelong)   { SU_ASSERT(s>=48); llen.set((s-48+7)>>3); return s; }
	else if(s>=520) { return create(p,r,true,checkun); }
	else            { SU_ASSERT(s>=16); slen.set((s-16+7)>>3); return s; }
}


int map::rsc_collection_litem_node::load ( byte* p )
{
	util::Zero(*this);
	int s=base_tag::load(p);
	s+=parentidx.setup(p,s,10,1); 
	s+=ub_align(p,s,0); s+=name.load(p+(s>>3)); 
	s+=ub_align(p,s,0); s+=note.load(p+(s>>3)); 
	s+=hidden.setup(p,s,1,1); 
	s+=ub_align(p,s,0); s+=trs.load(p+(s>>3)); 
	s+=trsanimid.setup(p,s,10,1); 
	return s;
}


// rsc_collection's code

int map::rsc_collection::create ( byte* p )
{
	int s=base_map::create(p,ALIGN);
	csign.set(CSIGN);
	fsign.set(FSIGN);
	flen.set((s+7)>>3);
	return s;
}


int map::rsc_collection::load ( byte* p )
{
	int n = base_map::load(p,ALIGN);
	if( !n ) return 0;
	if( fsign.get() != FSIGN ) return 0;
	if( csign.get() != CSIGN ) return 0;
	return n;
}


bool map::rsc_collection::writecontent( IDatatree* dtt, context& ctxt )
{
	util::Zero(ctxt);
	SU_REQUIRE_OR_FALSE( dtt );
	SU_REQUIRE_OR_FALSE( dtt->issequence(-1) );

	util::Strcopy( ctxt.mapname, SU_VERBOSE_STR("rsc.collection") );

	int n = dtt->size(-1);
	for( int i=0 ; i<n && ctxt.errcode==0 ; i++ )
	{
		int top = dtt->gettop();

		StringId tsid = push_tag(dtt,i,ctxt);
		if( !tsid )	break;

		if( tsid == sid::map_rsc_collection::map_rsc_common_end )
			writecontent_tag_rsc_common_end(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_anim_skelframe )
			writecontent_tag_rsc_collection_anim_skelframe(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_bitmap_dxmip )
			writecontent_tag_rsc_collection_bitmap_dxmip(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_litem_character )
			writecontent_tag_rsc_collection_litem_character(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_hotpoint )
			writecontent_tag_rsc_collection_hotpoint(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_hotspline )
			writecontent_tag_rsc_collection_hotspline(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_litem_light )
			writecontent_tag_rsc_collection_litem_light(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_litem_camera )
			writecontent_tag_rsc_collection_litem_camera(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_litem_bone )
			writecontent_tag_rsc_collection_litem_bone(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_hotsphere )
			writecontent_tag_rsc_collection_hotsphere(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_shading_technique )
			writecontent_tag_rsc_collection_shading_technique(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_bitmap_s3mip )
			writecontent_tag_rsc_collection_bitmap_s3mip(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_skeleton )
			writecontent_tag_rsc_collection_skeleton(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_mesh_blendprocess )
			writecontent_tag_rsc_collection_mesh_blendprocess(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_bitmap_drivermip )
			writecontent_tag_rsc_collection_bitmap_drivermip(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_litem_geometry )
			writecontent_tag_rsc_collection_litem_geometry(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_anim_klin_scl )
			writecontent_tag_rsc_collection_anim_klin_scl(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_anim )
			writecontent_tag_rsc_collection_anim(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_bitmap_glmip )
			writecontent_tag_rsc_collection_bitmap_glmip(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_anim_klin_rot )
			writecontent_tag_rsc_collection_anim_klin_rot(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_shading_pass )
			writecontent_tag_rsc_collection_shading_pass(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_skeleton_bone )
			writecontent_tag_rsc_collection_skeleton_bone(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_anim_morphframe )
			writecontent_tag_rsc_collection_anim_morphframe(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_bitmap_pvrmip )
			writecontent_tag_rsc_collection_bitmap_pvrmip(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_sourcefile )
			writecontent_tag_rsc_collection_sourcefile(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_hotbox )
			writecontent_tag_rsc_collection_hotbox(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_mesh_blendpass )
			writecontent_tag_rsc_collection_mesh_blendpass(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_list )
			writecontent_tag_rsc_collection_list(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_hotsegment )
			writecontent_tag_rsc_collection_hotsegment(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_hotcloud )
			writecontent_tag_rsc_collection_hotcloud(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_mesh )
			writecontent_tag_rsc_collection_mesh(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_litem_helper )
			writecontent_tag_rsc_collection_litem_helper(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_litem_export )
			writecontent_tag_rsc_collection_litem_export(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_mesh_surface )
			writecontent_tag_rsc_collection_mesh_surface(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_anim_klin_float )
			writecontent_tag_rsc_collection_anim_klin_float(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_shading_effect )
			writecontent_tag_rsc_collection_shading_effect(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_define )
			writecontent_tag_rsc_collection_define(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_anim_note )
			writecontent_tag_rsc_collection_anim_note(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_bitmap )
			writecontent_tag_rsc_collection_bitmap(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_shading_ps )
			writecontent_tag_rsc_collection_shading_ps(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_shading_gs )
			writecontent_tag_rsc_collection_shading_gs(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_morph_target )
			writecontent_tag_rsc_collection_morph_target(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_anim_klin_loc )
			writecontent_tag_rsc_collection_anim_klin_loc(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_shading_vs )
			writecontent_tag_rsc_collection_shading_vs(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_shading_constant )
			writecontent_tag_rsc_collection_shading_constant(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_shading_rstate )
			writecontent_tag_rsc_collection_shading_rstate(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_bitmap_layer )
			writecontent_tag_rsc_collection_bitmap_layer(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_mesh_vbo )
			writecontent_tag_rsc_collection_mesh_vbo(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_collection::map_rsc_collection_litem_node )
			writecontent_tag_rsc_collection_litem_node(*this,dtt,ctxt);

		dtt->settop( top );
	}
	return (ctxt.errcode==0);
}


bool map::rsc_collection::matchcontent( IDatatree* dtt )
{
	SU_REQUIRE_OR_FALSE( dtt );
	SU_REQUIRE_OR_FALSE( dtt->issequence(-1) );
	int top=dtt->gettop(), n=dtt->size(-1), i;
	for( i=0 ; i<n ; i++ )
	{
		dtt->push(-1,i);
		if( !dtt->ismapping(-1) )		break;
		dtt->push(-1,"tagid");
		pcstr tagid = dtt->asstring(-1);
		if( !sid::map_rsc_collection::HAS(tagid) )	break;
		dtt->pop(2);
	}
	dtt->settop(top);
	return (n>0) && (i==n);
}


// rsc_userdata's code

int map::rsc_userdata::create ( byte* p )
{
	int s=base_map::create(p,ALIGN);
	csign.set(CSIGN);
	fsign.set(FSIGN);
	flen.set((s+7)>>3);
	return s;
}


int map::rsc_userdata::load ( byte* p )
{
	int n = base_map::load(p,ALIGN);
	if( !n ) return 0;
	if( fsign.get() != FSIGN ) return 0;
	if( csign.get() != CSIGN ) return 0;
	return n;
}


bool map::rsc_userdata::writecontent( IDatatree* dtt, context& ctxt )
{
	util::Zero(ctxt);
	SU_REQUIRE_OR_FALSE( dtt );
	SU_REQUIRE_OR_FALSE( dtt->issequence(-1) );

	util::Strcopy( ctxt.mapname, SU_VERBOSE_STR("rsc.userdata") );

	int n = dtt->size(-1);
	for( int i=0 ; i<n && ctxt.errcode==0 ; i++ )
	{
		int top = dtt->gettop();

		StringId tsid = push_tag(dtt,i,ctxt);
		if( !tsid )	break;

		if( tsid == sid::map_rsc_userdata::map_rsc_common_end )
			writecontent_tag_rsc_common_end(*this,dtt,ctxt);
		else if( tsid == sid::map_rsc_userdata::map_rsc_userdata_content )
			writecontent_tag_rsc_userdata_content(*this,dtt,ctxt);

		dtt->settop( top );
	}
	return (ctxt.errcode==0);
}


bool map::rsc_userdata::matchcontent( IDatatree* dtt )
{
	SU_REQUIRE_OR_FALSE( dtt );
	SU_REQUIRE_OR_FALSE( dtt->issequence(-1) );
	int top=dtt->gettop(), n=dtt->size(-1), i;
	for( i=0 ; i<n ; i++ )
	{
		dtt->push(-1,i);
		if( !dtt->ismapping(-1) )		break;
		dtt->push(-1,"tagid");
		pcstr tagid = dtt->asstring(-1);
		if( !sid::map_rsc_userdata::HAS(tagid) )	break;
		dtt->pop(2);
	}
	dtt->settop(top);
	return (n>0) && (i==n);
}


// binarizer

StringId map::select ( su::IDatatree* dtt )
{
	if( rsc_collection::matchcontent(dtt) )		return sid::map_rsc_collection::TYPE;
	if( rsc_userdata::matchcontent(dtt) )		return sid::map_rsc_userdata::TYPE;
	return sid::null;
}


uint map::binarize ( IDatatree* dtt, byte* p, context& ctxt )
{
	SU_REQUIRE_OR_0( dtt );
	SU_REQUIRE_OR_0( dtt->issequence(-1) );
	SU_REQUIRE_OR_0( p );

	util::Zero(ctxt);

	StringId mapid = select(dtt);
	if( mapid==sid::map_rsc_collection::TYPE )
	{
		rsc_collection map; map.create(p);
		if( map.writecontent(dtt,ctxt) )	return map.bsize();
	}
	else if( mapid==sid::map_rsc_userdata::TYPE )
	{
		rsc_userdata map; map.create(p);
		if( map.writecontent(dtt,ctxt) )	return map.bsize();
	}
	else
	{
		Strcopy( ctxt.errmsg, "Invalid map !" );
		ctxt.errcode = map::context::EC_INVALID_MAP;
	}

	return 0;
}


uint map::binarize ( IDatatree* dtt, Pool* p, byte*& outaddr, context& ctxt )
{
	SU_REQUIRE_OR_0( p );
	SU_REQUIRE_OR_0( globals::binarizemaxbs );
	byte* baddr = (byte*) p->Alloc(globals::binarizemaxbs);
	SU_REQUIRE_OR_FALSE( baddr );
	util::Zero(baddr,globals::binarizemaxbs);
	byte* qaddr = Round16(baddr);

	uint bs = binarize(dtt,qaddr,ctxt);
	SU_ASSERT( bs < globals::binarizemaxbs );

	if(bs) outaddr = (byte*) p->DumpMemory(qaddr,bs);
	p->Free(baddr);

	return (outaddr && bs) ? bs : 0;
}


// reverter

StringId map::revert ( uint32 csign )
{
	if( rsc_collection::CSIGN==csign )		return sid::map_rsc_collection::TYPE;
	if( rsc_userdata::CSIGN==csign )		return sid::map_rsc_userdata::TYPE;
	return sid::null;
}


StringId map::revert ( StringId mapid, uint code )
{
	if( sid::map_rsc_collection::TYPE==mapid )
	{
		if( map::rsc_common_end::CODE==code )		return sid::map_rsc_collection::map_rsc_common_end;
		else if( map::rsc_collection_anim_skelframe::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_anim_skelframe;
		else if( map::rsc_collection_bitmap_dxmip::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_bitmap_dxmip;
		else if( map::rsc_collection_litem_character::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_litem_character;
		else if( map::rsc_collection_hotpoint::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_hotpoint;
		else if( map::rsc_collection_hotspline::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_hotspline;
		else if( map::rsc_collection_litem_light::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_litem_light;
		else if( map::rsc_collection_litem_camera::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_litem_camera;
		else if( map::rsc_collection_litem_bone::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_litem_bone;
		else if( map::rsc_collection_hotsphere::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_hotsphere;
		else if( map::rsc_collection_shading_technique::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_shading_technique;
		else if( map::rsc_collection_bitmap_s3mip::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_bitmap_s3mip;
		else if( map::rsc_collection_skeleton::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_skeleton;
		else if( map::rsc_collection_mesh_blendprocess::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_mesh_blendprocess;
		else if( map::rsc_collection_bitmap_drivermip::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_bitmap_drivermip;
		else if( map::rsc_collection_litem_geometry::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_litem_geometry;
		else if( map::rsc_collection_anim_klin_scl::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_anim_klin_scl;
		else if( map::rsc_collection_anim::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_anim;
		else if( map::rsc_collection_bitmap_glmip::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_bitmap_glmip;
		else if( map::rsc_collection_anim_klin_rot::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_anim_klin_rot;
		else if( map::rsc_collection_shading_pass::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_shading_pass;
		else if( map::rsc_collection_skeleton_bone::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_skeleton_bone;
		else if( map::rsc_collection_anim_morphframe::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_anim_morphframe;
		else if( map::rsc_collection_bitmap_pvrmip::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_bitmap_pvrmip;
		else if( map::rsc_collection_sourcefile::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_sourcefile;
		else if( map::rsc_collection_hotbox::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_hotbox;
		else if( map::rsc_collection_mesh_blendpass::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_mesh_blendpass;
		else if( map::rsc_collection_list::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_list;
		else if( map::rsc_collection_hotsegment::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_hotsegment;
		else if( map::rsc_collection_hotcloud::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_hotcloud;
		else if( map::rsc_collection_mesh::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_mesh;
		else if( map::rsc_collection_litem_helper::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_litem_helper;
		else if( map::rsc_collection_litem_export::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_litem_export;
		else if( map::rsc_collection_mesh_surface::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_mesh_surface;
		else if( map::rsc_collection_anim_klin_float::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_anim_klin_float;
		else if( map::rsc_collection_shading_effect::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_shading_effect;
		else if( map::rsc_collection_define::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_define;
		else if( map::rsc_collection_anim_note::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_anim_note;
		else if( map::rsc_collection_bitmap::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_bitmap;
		else if( map::rsc_collection_shading_ps::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_shading_ps;
		else if( map::rsc_collection_shading_gs::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_shading_gs;
		else if( map::rsc_collection_morph_target::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_morph_target;
		else if( map::rsc_collection_anim_klin_loc::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_anim_klin_loc;
		else if( map::rsc_collection_shading_vs::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_shading_vs;
		else if( map::rsc_collection_shading_constant::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_shading_constant;
		else if( map::rsc_collection_shading_rstate::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_shading_rstate;
		else if( map::rsc_collection_bitmap_layer::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_bitmap_layer;
		else if( map::rsc_collection_mesh_vbo::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_mesh_vbo;
		else if( map::rsc_collection_litem_node::CODE==code )		return sid::map_rsc_collection::map_rsc_collection_litem_node;
	}
	else if( sid::map_rsc_userdata::TYPE==mapid )
	{
		if( map::rsc_common_end::CODE==code )		return sid::map_rsc_userdata::map_rsc_common_end;
		else if( map::rsc_userdata_content::CODE==code )		return sid::map_rsc_userdata::map_rsc_userdata_content;
	}
	return sid::null;
}


bool map::info( StringId mapid, uint& csign, uint& fsign, uint& align )
{
	if( sid::map_rsc_collection::TYPE==mapid ) { csign=rsc_collection::CSIGN; fsign=rsc_collection::FSIGN; align=rsc_collection::ALIGN; return true; };
	if( sid::map_rsc_userdata::TYPE==mapid ) { csign=rsc_userdata::CSIGN; fsign=rsc_userdata::FSIGN; align=rsc_userdata::ALIGN; return true; };
	return false;
}



// !! This file has been automatically generated by the sugar sidl tool.
// !! Do not edit this file manually under risk of losing your changes.


