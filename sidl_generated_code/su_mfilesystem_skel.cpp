/*LIC-HDR********************************************************************
**
** Copyright (C) 2005-2011 AtOnce Technologies
**
** This file is part of the Sugar core-system framework.
**
** This file and the associated product may be used and distributed
** under the terms of a current License as defined by AtOnce Technologies
** and appearing in the file LICENSE.TXT included in the packaging of this file.
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
** See http://www.atonce-technologies.com or email info@atonce-technologies.com
** for informations about Sugar Framework and AtOnce Technologies others products
** License Agreements.
**
** Contact info@atonce-technologies.com if any conditions of this license
** are not clear to you.
**
*****************************************************************LIC-HDR*/


// !! This file has been automatically generated by the sugar sidl tool.
// !! Do not edit this file manually under risk of losing your changes.


//==== includes ====================================================================================

#include <sufw/precompiled/supch_core.h>
#include "su_idriverfs.h"
#include "..\base\su_iinterface.h"
#include "su_ifilesystem.h"
#include <stdarg.h>




//==== defines =====================================================================================

#ifndef SIDL_IMPL_CLASSNAME
#define SIDL_IMPL_CLASSNAME MFileSystem
#endif

#ifndef SIDL_IMPL_MUID
#define SIDL_IMPL_MUID 0x77b8dd6du
#endif

#ifndef SIDL_IMPL_REVISION
#define SIDL_IMPL_REVISION 0
#endif

#ifndef SIDL_IMPL_PACKAGE
#define SIDL_IMPL_PACKAGE "su.fw.core"
#endif

#ifndef SIDL_IMPL_ATTR_V
#define SIDL_IMPL_ATTR_V NULL
#endif

#ifndef SIDL_IMPL_ATTR_C
#define SIDL_IMPL_ATTR_C 0
#endif

#ifndef SIDL_STUB_CLASSNAME
#define SIDL_STUB_CLASSNAME MFileSystem_Stub
#endif

#ifndef SIDL_IMPL_INTERFACE
#define SIDL_IMPL_INTERFACE(I) ((I*)MFileSystem_get_interface(MFileSystem_stub_to_base(this),I::ClassId))
#endif


//==== declarations ================================================================================

namespace {

su::IInterface* MFileSystem_create_object( su::Pool*, su::Pool*, su::AnyList* );
void* MFileSystem_base_to_stub ( void* );
void* MFileSystem_stub_to_base ( void* );
su::addin::Builder* MFileSystem_builder ( );
uint MFileSystem_count_interface ( );
bool MFileSystem_enum_interface ( uint, su::classid*, pcstr* );
su::IInterface* MFileSystem_first_interface ( void* );
su::IInterface* MFileSystem_get_interface ( void*, su::classid );

}


//==== stub area ===================================================================================

#undef  SIDL_PROPER
#undef  SIDL_STUB
#undef  SIDL_BUILDER
#undef  SIDL_CODE
#define SIDL_STUB
#include "su_mfilesystem_stub.h"




//==== skeleton ====================================================================================

namespace {


struct MFileSystem
{

//---- bridges -------------------------------------------------------------------------------------

struct IFileSystem_t : public su::IFileSystem {
	// from IInterface
	::su::classbase         GetBase             (  ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return &(*m); }
	::su::addin::Builder *  GetBuilder          (  ) { return MFileSystem_builder(); }
	void                    Retain              (  ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); (*m).Retain(); }
	::uint                  CountRef            (  ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (*m).CountRef(); }
	void                    Release             (  ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); (*m).Release(); }
	::uint                  CountInterface      (  ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (*m).CountInterface(); }
	bool                    EnumInterface       ( ::uint p0,::su::classid * p1,::pcstr * p2 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (*m).EnumInterface(p0,p1,p2); }
	::su::IInterface *      GetInterface        ( ::su::classid p0 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (*m).GetInterface(p0); }
	// from IFileSystem
	bool                    IsExists            ( pcstr p0 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).IsExists(p0); }
	bool                    IsEmpty             ( pcstr p0 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).IsEmpty(p0); }
	bool                    IsDirectory         ( pcstr p0 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).IsDirectory(p0); }
	bool                    IsFile              ( pcstr p0 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).IsFile(p0); }
	bool                    IsReadOnly          ( pcstr p0 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).IsReadOnly(p0); }
	bool                    IsHidden            ( pcstr p0 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).IsHidden(p0); }
	bool                    IsSystem            ( pcstr p0 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).IsSystem(p0); }
	bool                    IsFullname          ( pcstr p0 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).IsFullname(p0); }
	bool                    IsInDirectory       ( pcstr p0,pcstr p1 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).IsInDirectory(p0,p1); }
	PString                 SplitExtension      ( pcstr p0 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).SplitExtension(p0); }
	bool                    HasExtension        ( pcstr p0,pcstr p1 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).HasExtension(p0,p1); }
	PString                 GetExtension        ( pcstr p0 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).GetExtension(p0); }
	PString                 GetBasename         ( pcstr p0 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).GetBasename(p0); }
	PString                 GetDirname          ( pcstr p0 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).GetDirname(p0); }
	PString                 GetFullname         ( pcstr p0 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).GetFullname(p0); }
	PString                 GetNormalized       ( pcstr p0 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).GetNormalized(p0); }
	bool                    GetSize             ( pcstr p0,uint64& p1 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).GetSize(p0,p1); }
	bool                    GetWriteTime        ( pcstr p0,Date& p1 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).GetWriteTime(p0,p1); }
	bool                    GetCreationTime     ( pcstr p0,Date& p1 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).GetCreationTime(p0,p1); }
	uint128                 HashContent         ( pcstr p0 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).HashContent(p0); }
	PString                 GetCurrentDirectory (  ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).GetCurrentDirectory(); }
	bool                    SetCurrentDirectory ( pcstr p0 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).SetCurrentDirectory(p0); }
	PString                 GetCommonPath       ( pcstr p0,pcstr p1 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).GetCommonPath(p0,p1); }
	PString                 GetCommonDirectory  ( pcstr p0,pcstr p1 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).GetCommonDirectory(p0,p1); }
	PString                 GetRelativeFrom     ( pcstr p0,pcstr p1 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).GetRelativeFrom(p0,p1); }
	PString                 FindFile            ( pcstr p0,pcstr p1 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).FindFile(p0,p1); }
	bool                    Hide                ( pcstr p0 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).Hide(p0); }
	bool                    Unhide              ( pcstr p0 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).Unhide(p0); }
	bool                    SetReadOnly         ( pcstr p0 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).SetReadOnly(p0); }
	bool                    SetReadWrite        ( pcstr p0 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).SetReadWrite(p0); }
	bool                    CopyFile            ( pcstr p0,pcstr p1,bool p2,Pool* p3 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).CopyFile(p0,p1,p2,p3); }
	bool                    MoveFile            ( pcstr p0,pcstr p1 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).MoveFile(p0,p1); }
	bool                    CreateFile          ( pcstr p0,bool p1,uint64 p2 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).CreateFile(p0,p1,p2); }
	bool                    CreateDir           ( pcstr p0 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).CreateDir(p0); }
	bool                    RemoveFile          ( pcstr p0 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).RemoveFile(p0); }
	bool                    RemoveDir           ( pcstr p0,bool p1 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).RemoveDir(p0,p1); }
	IFileReader*            OpenReader          ( pcstr p0,Pool* p1 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).OpenReader(p0,p1); }
	IFileView*              OpenView            ( pcstr p0,Pool* p1 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).OpenView(p0,p1); }
	IFileBurst*             OpenBurst           ( pcstr p0,Pool* p1 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).OpenBurst(p0,p1); }
	IFileWriter*            OpenWriter          ( pcstr p0,Pool* p1,bool p2,bool p3 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).OpenWriter(p0,p1,p2,p3); }
	IDirectory*             OpenDir             ( pcstr p0,Pool* p1 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).OpenDir(p0,p1); }
	uint                    GlobFiles           ( pcstr p0,vector<PString>& p1,Pool* p2 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).GlobFiles(p0,p1,p2); }
	bool                    DumpToFile          ( pcstr p0,void* p1,uint p2,bool p3 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).DumpToFile(p0,p1,p2,p3); }
	bool                    DumpFromFile        ( uint& p0,pcstr p1,void* p2,uint p3 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).DumpFromFile(p0,p1,p2,p3); }
	bool                    DumpFromFile        ( uint& p0,void*& p1,pcstr p2,Pool* p3 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).DumpFromFile(p0,p1,p2,p3); }
	bool                    StartInflateFile    ( IFileWriter* p0,IFileReader* p1,Pool* p2 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).StartInflateFile(p0,p1,p2); }
	int                     ContinueInflateFile ( uint p0 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).ContinueInflateFile(p0); }
	void                    AbortInflateFile    (  ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); (m->stub).AbortInflateFile(); }
	bool                    DumpSliceFromFile   ( void* p0,pcstr p1,uint p2,int p3 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).DumpSliceFromFile(p0,p1,p2,p3); }
	bool                    Mount               ( pcstr p0,pcstr p1,pcstr p2 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).Mount(p0,p1,p2); }
	bool                    Unmount             ( pcstr p0 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).Unmount(p0); }
	void                    UnmountAll          (  ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); (m->stub).UnmountAll(); }
	int                     CountMount          (  ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).CountMount(); }
	pcstr                   EnumMountPath       ( int p0 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).EnumMountPath(p0); }
	pcstr                   EnumMountOptions    ( int p0 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).EnumMountOptions(p0); }
	PString                 GetHostPath         ( pcstr p0 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).GetHostPath(p0); }
	PString                 GetVirtualPath      ( pcstr p0 ) { MFileSystem* m = SU_DELEGATE_BASEPTR(MFileSystem,IFileSystem_i,this); return (m->stub).GetVirtualPath(p0); }
} IFileSystem_i;


//---- stub nested object --------------------------------------------------------------------------

MFileSystem_Stub stub;


//---- skeleton management code area ---------------------------------------------------------------

int refcount;
Pool* nestp;


void Retain ( )
{
	refcount++;
}


uint CountRef ( )
{
	return refcount;
}


void Release ( )
{
	if( refcount==1 )
		Destroy( this );
	else
		refcount--;
}


uint CountInterface ( )
{
	return MFileSystem_count_interface();
}


bool EnumInterface ( uint i, su::classid* cid, pcstr* cname )
{
	return MFileSystem_enum_interface(i,cid,cname);
}


su::IInterface* GetInterface ( classid cid )
{
	SU_IMPLEMENTS_MEMBER( IFileSystem_i, cid );
	return NULL;
}


static MFileSystem* Create( Pool* np, Pool* dp, AnyList* o )
{
	if( !np )	return NULL;
	MFileSystem* m = np->New<MFileSystem>();
	if( !m )	return NULL;
	m->refcount = 1;
	m->nestp = np;
	if( !m->stub.Init(dp,o) )
	{
		np->Delete( m );
		return NULL;
	}
	return m;
}


static void Destroy( MFileSystem* m )
{
	m->stub.Shut();
	m->refcount=0;
	m->nestp->Delete( m );
}

};

}




//==== builder =====================================================================================


SU_BEGIN_BUILDER( MFileSystem )

su::classid GetMUID ( ) { return SIDL_IMPL_MUID; }
pcstr GetMClassname ( ) { return "MFileSystem"; }
uint32 GetRevision ( ) { return SIDL_IMPL_REVISION; }
pcstr GetPackage ( ) { return SIDL_IMPL_PACKAGE; }
uint CountInterface ( ) { return MFileSystem_count_interface(); }
bool EnumInterface ( uint i, su::classid* cid, pcstr* cname ) { return MFileSystem_enum_interface(i,cid,cname); }
su::IInterface* FirstInterface ( void* base ) { return MFileSystem_first_interface(base); }
su::IInterface* GetInterface ( void* base, su::classid cid ) { return MFileSystem_get_interface(base,cid); }
su::IInterface* CreateObject( su::Pool* nestp, su::Pool* datap, su::AnyList* opts ) { return MFileSystem_create_object(nestp,datap,opts); }
void* BaseToStub ( void* base ) { return MFileSystem_base_to_stub(base); }
void* StubToBase ( void* base ) { return MFileSystem_stub_to_base(base); }
uint CountSwitch ( ) { return 0; }
bool EnumSwitch ( uint, su::ISwitch::Desc& ) { return false; }

SU_END_BUILDER( MFileSystem )




//==== definitions =================================================================================


namespace {


su::IInterface* MFileSystem_create_object( su::Pool* nestp, su::Pool* datap, su::AnyList* opts )
{
	MFileSystem* m = MFileSystem::Create( nestp, datap, opts );
	SU_REQUIRE_OR_NULL( m );
	return &m->IFileSystem_i;
}


void* MFileSystem_base_to_stub ( void* base )
{
	SU_REQUIRE_OR_NULL( base );
	return &(((MFileSystem*)base)->stub);
}


void* MFileSystem_stub_to_base ( void* stubp )
{
	SU_REQUIRE_OR_NULL( stubp );
	return SU_DELEGATE_BASEPTR(MFileSystem,stub,stubp);
}


su::addin::Builder* MFileSystem_builder ( )
{
	return &_builder_MFileSystem;
}


uint MFileSystem_count_interface ( )
{
	return 1;
}


bool MFileSystem_enum_interface ( uint i, su::classid* cid, pcstr* cname )
{
	static const su::classid cids[] = { su::IFileSystem::ClassId };
	static const pcstr cnames[] = { "IFileSystem" };
	SU_REQUIRE_OR_FALSE( i<1 );
	if( cid )   *cid   = cids[i];
	if( cname ) *cname = cnames[i];
	return true;
}


su::IInterface* MFileSystem_first_interface ( void* base )
{
	SU_REQUIRE_OR_NULL( base );
	return &(((MFileSystem*)base)->IFileSystem_i);
}


su::IInterface* MFileSystem_get_interface ( void* base, su::classid cid )
{
	SU_REQUIRE_OR_NULL( base );
	return ((MFileSystem*)base)->GetInterface(cid);
}


}


// !! This file has been automatically generated by the sugar sidl tool.
// !! Do not edit this file manually under risk of losing your changes.

