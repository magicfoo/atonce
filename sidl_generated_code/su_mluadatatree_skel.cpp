/*LIC-HDR********************************************************************
**
** Copyright (C) 2005-2011 AtOnce Technologies
**
** This file is part of the Sugar core-system framework.
**
** This file and the associated product may be used and distributed
** under the terms of a current License as defined by AtOnce Technologies
** and appearing in the file LICENSE.TXT included in the packaging of this file.
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
** See http://www.atonce-technologies.com or email info@atonce-technologies.com
** for informations about Sugar Framework and AtOnce Technologies others products
** License Agreements.
**
** Contact info@atonce-technologies.com if any conditions of this license
** are not clear to you.
**
*****************************************************************LIC-HDR*/


// !! This file has been automatically generated by the sugar sidl tool.
// !! Do not edit this file manually under risk of losing your changes.


//==== includes ====================================================================================

#include <sufw/precompiled/supch_core.h>
#include "..\..\core\base\su_iinterface.h"
#include "..\..\asset\su_idatatree.h"
#include "su_iluadatatree.h"
#include <stdarg.h>




//==== defines =====================================================================================

#ifndef SIDL_IMPL_CLASSNAME
#define SIDL_IMPL_CLASSNAME MLuaDatatree
#endif

#ifndef SIDL_IMPL_MUID
#define SIDL_IMPL_MUID 0x825744a7u
#endif

#ifndef SIDL_IMPL_REVISION
#define SIDL_IMPL_REVISION 0
#endif

#ifndef SIDL_IMPL_PACKAGE
#define SIDL_IMPL_PACKAGE "su.fw.lang"
#endif

#ifndef SIDL_IMPL_ATTR_V
#define SIDL_IMPL_ATTR_V NULL
#endif

#ifndef SIDL_IMPL_ATTR_C
#define SIDL_IMPL_ATTR_C 0
#endif

#ifndef SIDL_STUB_CLASSNAME
#define SIDL_STUB_CLASSNAME MLuaDatatree_Stub
#endif

#ifndef SIDL_IMPL_INTERFACE
#define SIDL_IMPL_INTERFACE(I) ((I*)MLuaDatatree_get_interface(MLuaDatatree_stub_to_base(this),I::ClassId))
#endif


//==== declarations ================================================================================

namespace {

su::IInterface* MLuaDatatree_create_object( su::Pool*, su::Pool*, su::AnyList* );
void* MLuaDatatree_base_to_stub ( void* );
void* MLuaDatatree_stub_to_base ( void* );
su::addin::Builder* MLuaDatatree_builder ( );
uint MLuaDatatree_count_interface ( );
bool MLuaDatatree_enum_interface ( uint, su::classid*, pcstr* );
su::IInterface* MLuaDatatree_first_interface ( void* );
su::IInterface* MLuaDatatree_get_interface ( void*, su::classid );

}


//==== stub area ===================================================================================

#undef  SIDL_PROPER
#undef  SIDL_STUB
#undef  SIDL_BUILDER
#undef  SIDL_CODE
#define SIDL_STUB
#include "su_mluadatatree_stub.h"




//==== skeleton ====================================================================================

namespace {


struct MLuaDatatree
{

//---- bridges -------------------------------------------------------------------------------------

struct IDatatree_t : public su::IDatatree {
	// from IInterface
	::su::classbase         GetBase        (  ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); return &(*m); }
	::su::addin::Builder *  GetBuilder     (  ) { return MLuaDatatree_builder(); }
	void                    Retain         (  ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); (*m).Retain(); }
	::uint                  CountRef       (  ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); return (*m).CountRef(); }
	void                    Release        (  ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); (*m).Release(); }
	::uint                  CountInterface (  ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); return (*m).CountInterface(); }
	bool                    EnumInterface  ( ::uint p0,::su::classid * p1,::pcstr * p2 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); return (*m).EnumInterface(p0,p1,p2); }
	::su::IInterface *      GetInterface   ( ::su::classid p0 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); return (*m).GetInterface(p0); }
	// from IDatatree
	bool                    isempty        (  ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); return (m->stub).isempty(); }
	int                     getcount       (  ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); return (m->stub).getcount(); }
	void                    setcount       ( int p0 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); (m->stub).setcount(p0); }
	int                     gettop         (  ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); return (m->stub).gettop(); }
	void                    settop         ( int p0 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); (m->stub).settop(p0); }
	int                     baseindex      ( int p0 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); return (m->stub).baseindex(p0); }
	int                     topindex       ( int p0 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); return (m->stub).topindex(p0); }
	void                    pop            ( int p0 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); (m->stub).pop(p0); }
	void                    push           ( int p0 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); (m->stub).push(p0); }
	void                    insert         ( int p0 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); (m->stub).insert(p0); }
	void                    remove         ( int p0 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); (m->stub).remove(p0); }
	void                    replace        ( int p0 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); (m->stub).replace(p0); }
	bool                    equal          ( int p0,int p1 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); return (m->stub).equal(p0,p1); }
	bool                    isnil          ( int p0 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); return (m->stub).isnil(p0); }
	bool                    isboolean      ( int p0 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); return (m->stub).isboolean(p0); }
	bool                    isblob         ( int p0 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); return (m->stub).isblob(p0); }
	bool                    isstring       ( int p0 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); return (m->stub).isstring(p0); }
	bool                    isinteger      ( int p0 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); return (m->stub).isinteger(p0); }
	bool                    isnumber       ( int p0 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); return (m->stub).isnumber(p0); }
	bool                    isscalar       ( int p0 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); return (m->stub).isscalar(p0); }
	bool                    iscollection   ( int p0 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); return (m->stub).iscollection(p0); }
	bool                    issequence     ( int p0 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); return (m->stub).issequence(p0); }
	bool                    ismapping      ( int p0 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); return (m->stub).ismapping(p0); }
	NodeType                nodetype       ( int p0 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); return (m->stub).nodetype(p0); }
	ScalarType              scalartype     ( int p0 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); return (m->stub).scalartype(p0); }
	bool                    asboolean      ( int p0 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); return (m->stub).asboolean(p0); }
	pcstr                   asstring       ( int p0 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); return (m->stub).asstring(p0); }
	int                     asinteger      ( int p0 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); return (m->stub).asinteger(p0); }
	float                   asnumber       ( int p0 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); return (m->stub).asnumber(p0); }
	byte*                   asblob         ( int p0,int* p1 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); return (m->stub).asblob(p0,p1); }
	bool                    toboolean      ( int p0 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); return (m->stub).toboolean(p0); }
	pcstr                   tostring       ( int p0 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); return (m->stub).tostring(p0); }
	int                     tointeger      ( int p0 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); return (m->stub).tointeger(p0); }
	float                   tonumber       ( int p0 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); return (m->stub).tonumber(p0); }
	void                    clear          ( int p0 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); (m->stub).clear(p0); }
	int                     size           ( int p0 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); return (m->stub).size(p0); }
	void                    resize         ( int p0,int p1 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); (m->stub).resize(p0,p1); }
	void                    push           ( int p0,int p1 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); (m->stub).push(p0,p1); }
	void                    store          ( int p0,int p1 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); (m->stub).store(p0,p1); }
	void                    append         ( int p0 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); (m->stub).append(p0); }
	void                    pushchain      ( int p0,pcstr p1 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); (m->stub).pushchain(p0,p1); }
	void                    push           ( int p0,pcstr p1 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); (m->stub).push(p0,p1); }
	void                    store          ( int p0,pcstr p1 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); (m->stub).store(p0,p1); }
	bool                    haskey         ( int p0,pcstr p1 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); return (m->stub).haskey(p0,p1); }
	pcstr                   enumkey        ( int p0,pcstr p1 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); return (m->stub).enumkey(p0,p1); }
	void                    unkey          ( int p0,pcstr p1 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); (m->stub).unkey(p0,p1); }
	void                    pushnil        (  ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); (m->stub).pushnil(); }
	void                    pushscalar     ( pcstr p0 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); (m->stub).pushscalar(p0); }
	void                    pushboolean    ( bool p0 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); (m->stub).pushboolean(p0); }
	void                    pushstring     ( pcstr p0 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); (m->stub).pushstring(p0); }
	void                    pushstring     ( pcstr p0,pcstr p1 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); (m->stub).pushstring(p0,p1); }
	void                    pushinteger    ( int p0 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); (m->stub).pushinteger(p0); }
	void                    pushnumber     ( float p0 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); (m->stub).pushnumber(p0); }
	void                    pushblob       ( byte* p0,int p1 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); (m->stub).pushblob(p0,p1); }
	void                    pushsequence   ( int p0 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); (m->stub).pushsequence(p0); }
	void                    pushmapping    (  ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); (m->stub).pushmapping(); }
	void                    storeproperty  ( int p0 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); (m->stub).storeproperty(p0); }
	void                    pushproperty   ( int p0 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,IDatatree_i,this); (m->stub).pushproperty(p0); }
} IDatatree_i;


struct ILuaDatatree_t : public su::ILuaDatatree {
	// from IInterface
	::su::classbase         GetBase        (  ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,ILuaDatatree_i,this); return &(*m); }
	::su::addin::Builder *  GetBuilder     (  ) { return MLuaDatatree_builder(); }
	void                    Retain         (  ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,ILuaDatatree_i,this); (*m).Retain(); }
	::uint                  CountRef       (  ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,ILuaDatatree_i,this); return (*m).CountRef(); }
	void                    Release        (  ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,ILuaDatatree_i,this); (*m).Release(); }
	::uint                  CountInterface (  ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,ILuaDatatree_i,this); return (*m).CountInterface(); }
	bool                    EnumInterface  ( ::uint p0,::su::classid * p1,::pcstr * p2 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,ILuaDatatree_i,this); return (*m).EnumInterface(p0,p1,p2); }
	::su::IInterface *      GetInterface   ( ::su::classid p0 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,ILuaDatatree_i,this); return (*m).GetInterface(p0); }
	// from ILuaDatatree
	bool                    Setup          ( lua_State* p0 ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,ILuaDatatree_i,this); return (m->stub).Setup(p0); }
	lua_State*              GetState       (  ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,ILuaDatatree_i,this); return (m->stub).GetState(); }
	void                    PushPropTable  (  ) { MLuaDatatree* m = SU_DELEGATE_BASEPTR(MLuaDatatree,ILuaDatatree_i,this); (m->stub).PushPropTable(); }
} ILuaDatatree_i;


//---- stub nested object --------------------------------------------------------------------------

MLuaDatatree_Stub stub;


//---- skeleton management code area ---------------------------------------------------------------

int refcount;
Pool* nestp;


void Retain ( )
{
	refcount++;
}


uint CountRef ( )
{
	return refcount;
}


void Release ( )
{
	if( refcount==1 )
		Destroy( this );
	else
		refcount--;
}


uint CountInterface ( )
{
	return MLuaDatatree_count_interface();
}


bool EnumInterface ( uint i, su::classid* cid, pcstr* cname )
{
	return MLuaDatatree_enum_interface(i,cid,cname);
}


su::IInterface* GetInterface ( classid cid )
{
	SU_IMPLEMENTS_MEMBER( IDatatree_i, cid );
	SU_IMPLEMENTS_MEMBER( ILuaDatatree_i, cid );
	return NULL;
}


static MLuaDatatree* Create( Pool* np, Pool* dp, AnyList* o )
{
	if( !np )	return NULL;
	MLuaDatatree* m = np->New<MLuaDatatree>();
	if( !m )	return NULL;
	m->refcount = 1;
	m->nestp = np;
	if( !m->stub.Init(dp,o) )
	{
		np->Delete( m );
		return NULL;
	}
	return m;
}


static void Destroy( MLuaDatatree* m )
{
	m->stub.Shut();
	m->refcount=0;
	m->nestp->Delete( m );
}

};

}




//==== builder =====================================================================================


SU_BEGIN_BUILDER( MLuaDatatree )

su::classid GetMUID ( ) { return SIDL_IMPL_MUID; }
pcstr GetMClassname ( ) { return "MLuaDatatree"; }
uint32 GetRevision ( ) { return SIDL_IMPL_REVISION; }
pcstr GetPackage ( ) { return SIDL_IMPL_PACKAGE; }
uint CountInterface ( ) { return MLuaDatatree_count_interface(); }
bool EnumInterface ( uint i, su::classid* cid, pcstr* cname ) { return MLuaDatatree_enum_interface(i,cid,cname); }
su::IInterface* FirstInterface ( void* base ) { return MLuaDatatree_first_interface(base); }
su::IInterface* GetInterface ( void* base, su::classid cid ) { return MLuaDatatree_get_interface(base,cid); }
su::IInterface* CreateObject( su::Pool* nestp, su::Pool* datap, su::AnyList* opts ) { return MLuaDatatree_create_object(nestp,datap,opts); }
void* BaseToStub ( void* base ) { return MLuaDatatree_base_to_stub(base); }
void* StubToBase ( void* base ) { return MLuaDatatree_stub_to_base(base); }
uint CountSwitch ( ) { return 0; }
bool EnumSwitch ( uint, su::ISwitch::Desc& ) { return false; }

SU_END_BUILDER( MLuaDatatree )




//==== definitions =================================================================================


namespace {


su::IInterface* MLuaDatatree_create_object( su::Pool* nestp, su::Pool* datap, su::AnyList* opts )
{
	MLuaDatatree* m = MLuaDatatree::Create( nestp, datap, opts );
	SU_REQUIRE_OR_NULL( m );
	return &m->IDatatree_i;
}


void* MLuaDatatree_base_to_stub ( void* base )
{
	SU_REQUIRE_OR_NULL( base );
	return &(((MLuaDatatree*)base)->stub);
}


void* MLuaDatatree_stub_to_base ( void* stubp )
{
	SU_REQUIRE_OR_NULL( stubp );
	return SU_DELEGATE_BASEPTR(MLuaDatatree,stub,stubp);
}


su::addin::Builder* MLuaDatatree_builder ( )
{
	return &_builder_MLuaDatatree;
}


uint MLuaDatatree_count_interface ( )
{
	return 2;
}


bool MLuaDatatree_enum_interface ( uint i, su::classid* cid, pcstr* cname )
{
	static const su::classid cids[] = { su::IDatatree::ClassId, su::ILuaDatatree::ClassId };
	static const pcstr cnames[] = { "IDatatree", "ILuaDatatree" };
	SU_REQUIRE_OR_FALSE( i<2 );
	if( cid )   *cid   = cids[i];
	if( cname ) *cname = cnames[i];
	return true;
}


su::IInterface* MLuaDatatree_first_interface ( void* base )
{
	SU_REQUIRE_OR_NULL( base );
	return &(((MLuaDatatree*)base)->IDatatree_i);
}


su::IInterface* MLuaDatatree_get_interface ( void* base, su::classid cid )
{
	SU_REQUIRE_OR_NULL( base );
	return ((MLuaDatatree*)base)->GetInterface(cid);
}


}


// !! This file has been automatically generated by the sugar sidl tool.
// !! Do not edit this file manually under risk of losing your changes.

