/*LIC-HDR********************************************************************
**
** Copyright (C) 2005-2011 AtOnce Technologies
**
** This file is part of the Sugar core-system framework.
**
** This file and the associated product may be used and distributed
** under the terms of a current License as defined by AtOnce Technologies
** and appearing in the file LICENSE.TXT included in the packaging of this file.
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
** See http://www.atonce-technologies.com or email info@atonce-technologies.com
** for informations about Sugar Framework and AtOnce Technologies others products
** License Agreements.
**
** Contact info@atonce-technologies.com if any conditions of this license
** are not clear to you.
**
*****************************************************************LIC-HDR*/


// !! This file has been automatically generated by the sugar sidl tool.
// !! Do not edit this file manually under risk of losing your changes.


//==== includes ====================================================================================

#include <sufw/precompiled/supch_core.h>
#include "..\..\core\base\su_iinterface.h"
#include "su_iluautil.h"
#include "..\..\core\base\su_iswitch.h"
#include <stdarg.h>




//==== defines =====================================================================================

#ifndef SIDL_IMPL_CLASSNAME
#define SIDL_IMPL_CLASSNAME MLuaUtil
#endif

#ifndef SIDL_IMPL_MUID
#define SIDL_IMPL_MUID 0xa4767feeu
#endif

#ifndef SIDL_IMPL_QUALIFIER
#define SIDL_IMPL_QUALIFIER static
#endif

#ifndef SIDL_IMPL_IS_STATIC
#define SIDL_IMPL_IS_STATIC 
#endif

#ifndef SIDL_IMPL_SWITCHED
#define SIDL_IMPL_SWITCHED 
#endif

#ifndef SIDL_IMPL_REVISION
#define SIDL_IMPL_REVISION 0
#endif

#ifndef SIDL_IMPL_PACKAGE
#define SIDL_IMPL_PACKAGE "su.fw.lang"
#endif

#ifndef SIDL_IMPL_ATTR_V
#define SIDL_IMPL_ATTR_V NULL
#endif

#ifndef SIDL_IMPL_ATTR_C
#define SIDL_IMPL_ATTR_C 0
#endif

#ifndef SIDL_STUB_CLASSNAME
#define SIDL_STUB_CLASSNAME MLuaUtil_Stub
#endif

#ifndef SIDL_IMPL_INTERFACE
#define SIDL_IMPL_INTERFACE(I) ((I*)MLuaUtil_get_interface(MLuaUtil_stub_to_base(this),I::ClassId))
#endif


//==== declarations ================================================================================

namespace {

su::IInterface* MLuaUtil_create_object( su::Pool*, su::Pool*, su::AnyList* );
void* MLuaUtil_base_to_stub ( void* );
void* MLuaUtil_stub_to_base ( void* );
su::addin::Builder* MLuaUtil_builder ( );
uint MLuaUtil_count_interface ( );
bool MLuaUtil_enum_interface ( uint, su::classid*, pcstr* );
su::IInterface* MLuaUtil_first_interface ( void* );
su::IInterface* MLuaUtil_get_interface ( void*, su::classid );
uint MLuaUtil_count_switch ( );
bool MLuaUtil_enum_switch ( uint, su::ISwitch::Desc& );
int MLuaUtil_find_switch ( pcstr );
bool MLuaUtil_call_switch_stack ( void*, uint, void*, va_list );
bool MLuaUtil_call_switch_mem ( void*, uint, su::Any*, int, su::Any* );

}


//==== stub area ===================================================================================

#undef  SIDL_PROPER
#undef  SIDL_STUB
#undef  SIDL_BUILDER
#undef  SIDL_CODE
#define SIDL_STUB
#include "su_mluautil_stub.h"




//==== skeleton ====================================================================================

namespace {


struct MLuaUtil
{

//---- bridges -------------------------------------------------------------------------------------

struct ILuaUtil_t : public su::ILuaUtil {
	// from IInterface
	::su::classbase         GetBase               (  ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return &(*m); }
	::su::addin::Builder *  GetBuilder            (  ) { return MLuaUtil_builder(); }
	void                    Retain                (  ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); (*m).Retain(); }
	::uint                  CountRef              (  ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (*m).CountRef(); }
	void                    Release               (  ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); (*m).Release(); }
	::uint                  CountInterface        (  ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (*m).CountInterface(); }
	bool                    EnumInterface         ( ::uint p0,::su::classid * p1,::pcstr * p2 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (*m).EnumInterface(p0,p1,p2); }
	::su::IInterface *      GetInterface          ( ::su::classid p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (*m).GetInterface(p0); }
	// from ILuaUtil
	int                     Lua_hash32            ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).Lua_hash32(p0); }
	int                     Lua_hash128           ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).Lua_hash128(p0); }
	int                     Lua_sid               ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).Lua_sid(p0); }
	int                     Lua_newBlob           ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).Lua_newBlob(p0); }
	int                     Lua_newArray          ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).Lua_newArray(p0); }
	int                     Lua_setConsoleFile    ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).Lua_setConsoleFile(p0); }
	int                     Lua_getTime           ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).Lua_getTime(p0); }
	int                     Lua_getDate           ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).Lua_getDate(p0); }
	int                     Lua_getNow            ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).Lua_getNow(p0); }
	int                     Lua_selectMap         ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).Lua_selectMap(p0); }
	int                     Lua_binarizeMap       ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).Lua_binarizeMap(p0); }
	int                     Lua_listMaps          ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).Lua_listMaps(p0); }
	int                     Lua_listTags          ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).Lua_listTags(p0); }
	int                     Lua_openPak           ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).Lua_openPak(p0); }
	int                     LuaPak_getHeader      ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaPak_getHeader(p0); }
	int                     LuaPak_getDesc        ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaPak_getDesc(p0); }
	int                     LuaPak_enumDesc       ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaPak_enumDesc(p0); }
	int                     LuaPak_extractBytes   ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaPak_extractBytes(p0); }
	int                     LuaPak_extractRaw     ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaPak_extractRaw(p0); }
	int                     LuaPak_extractContent ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaPak_extractContent(p0); }
	int                     LuaPak_startUpdating  ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaPak_startUpdating(p0); }
	int                     LuaPak_updateLabel    ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaPak_updateLabel(p0); }
	int                     LuaPak_updateRevision ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaPak_updateRevision(p0); }
	int                     LuaPak_updateContent  ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaPak_updateContent(p0); }
	int                     LuaPak_endUpdating    ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaPak_endUpdating(p0); }
	int                     LuaPak_optimize       ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaPak_optimize(p0); }
	int                     LuaPak_gc             ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaPak_gc(p0); }
	int                     Lua_openZip           ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).Lua_openZip(p0); }
	int                     LuaZip_len            ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaZip_len(p0); }
	int                     LuaZip_comment        ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaZip_comment(p0); }
	int                     LuaZip_tell           ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaZip_tell(p0); }
	int                     LuaZip_eof            ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaZip_eof(p0); }
	int                     LuaZip_firstFile      ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaZip_firstFile(p0); }
	int                     LuaZip_nextFile       ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaZip_nextFile(p0); }
	int                     LuaZip_seekFile       ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaZip_seekFile(p0); }
	int                     LuaZip_aboutCurrent   ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaZip_aboutCurrent(p0); }
	int                     LuaZip_openCurrent    ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaZip_openCurrent(p0); }
	int                     LuaZip_closeCurrent   ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaZip_closeCurrent(p0); }
	int                     LuaZip_readCurrent    ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaZip_readCurrent(p0); }
	int                     LuaZip_gc             ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaZip_gc(p0); }
	int                     Lua_newVector         ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).Lua_newVector(p0); }
	int                     Lua_vcpy              ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).Lua_vcpy(p0); }
	int                     Lua_veq               ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).Lua_veq(p0); }
	int                     Lua_vlen              ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).Lua_vlen(p0); }
	int                     Lua_vstr              ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).Lua_vstr(p0); }
	int                     Lua_vlb               ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).Lua_vlb(p0); }
	int                     Lua_vlh               ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).Lua_vlh(p0); }
	int                     Lua_vlw               ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).Lua_vlw(p0); }
	int                     Lua_vld               ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).Lua_vld(p0); }
	int                     Lua_vlq               ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).Lua_vlq(p0); }
	int                     Lua_vlf               ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).Lua_vlf(p0); }
	int                     Lua_vsb               ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).Lua_vsb(p0); }
	int                     Lua_vsh               ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).Lua_vsh(p0); }
	int                     Lua_vsw               ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).Lua_vsw(p0); }
	int                     Lua_vsd               ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).Lua_vsd(p0); }
	int                     Lua_vsq               ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).Lua_vsq(p0); }
	int                     Lua_vsf               ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).Lua_vsf(p0); }
	int                     Lua_newCursor         ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).Lua_newCursor(p0); }
	int                     LuaCurs_size          ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaCurs_size(p0); }
	int                     LuaCurs_pos           ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaCurs_pos(p0); }
	int                     LuaCurs_seek          ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaCurs_seek(p0); }
	int                     LuaCurs_backward      ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaCurs_backward(p0); }
	int                     LuaCurs_hasbackward   ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaCurs_hasbackward(p0); }
	int                     LuaCurs_gobackward    ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaCurs_gobackward(p0); }
	int                     LuaCurs_forward       ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaCurs_forward(p0); }
	int                     LuaCurs_hasforward    ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaCurs_hasforward(p0); }
	int                     LuaCurs_goforward     ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaCurs_goforward(p0); }
	int                     LuaCurs_align         ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaCurs_align(p0); }
	int                     LuaCurs_uread         ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaCurs_uread(p0); }
	int                     LuaCurs_sread         ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaCurs_sread(p0); }
	int                     LuaCurs_sizeB         ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaCurs_sizeB(p0); }
	int                     LuaCurs_seekB         ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaCurs_seekB(p0); }
	int                     LuaCurs_usedB         ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaCurs_usedB(p0); }
	int                     LuaCurs_leftB         ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaCurs_leftB(p0); }
	int                     LuaCurs_findB         ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaCurs_findB(p0); }
	int                     LuaCurs_writeu8       ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaCurs_writeu8(p0); }
	int                     LuaCurs_writes8       ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaCurs_writes8(p0); }
	int                     LuaCurs_writeu16      ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaCurs_writeu16(p0); }
	int                     LuaCurs_writes16      ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaCurs_writes16(p0); }
	int                     LuaCurs_writeu32      ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaCurs_writeu32(p0); }
	int                     LuaCurs_writes32      ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaCurs_writes32(p0); }
	int                     LuaCurs_writef32      ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaCurs_writef32(p0); }
	int                     LuaCurs_gc            ( lua_State* p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ILuaUtil_i,this); return (m->stub).LuaCurs_gc(p0); }
} ILuaUtil_i;


struct ISwitch_t : public su::ISwitch {
	// from IInterface
	::su::classbase         GetBase        (  ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ISwitch_i,this); return &(*m); }
	::su::addin::Builder *  GetBuilder     (  ) { return MLuaUtil_builder(); }
	void                    Retain         (  ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ISwitch_i,this); (*m).Retain(); }
	::uint                  CountRef       (  ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ISwitch_i,this); return (*m).CountRef(); }
	void                    Release        (  ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ISwitch_i,this); (*m).Release(); }
	::uint                  CountInterface (  ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ISwitch_i,this); return (*m).CountInterface(); }
	bool                    EnumInterface  ( ::uint p0,::su::classid * p1,::pcstr * p2 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ISwitch_i,this); return (*m).EnumInterface(p0,p1,p2); }
	::su::IInterface *      GetInterface   ( ::su::classid p0 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ISwitch_i,this); return (*m).GetInterface(p0); }
	// from ISwitch
	::uint                  CountSwitch    (  ) { return MLuaUtil_count_switch(); }
	bool                    EnumSwitch     ( ::uint p0,::su::ISwitch::Desc & p1 ) { return MLuaUtil_enum_switch(p0,p1); }
	int                     FindSwitch     ( ::pcstr p0 ) { return MLuaUtil_find_switch(p0); }
	bool                    CallSwitch     ( ::uint p0,void * p1,... ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ISwitch_i,this); va_list vl; va_start(vl,p1); return MLuaUtil_call_switch_stack(m,p0,p1,vl); va_end(vl); }
	bool                    CallSwitchMem  ( ::uint p0,::su::Any * p1,int p2,::su::Any * p3 ) { MLuaUtil* m = SU_DELEGATE_BASEPTR(MLuaUtil,ISwitch_i,this); return MLuaUtil_call_switch_mem(m,p0,p1,p2,p3); }
} ISwitch_i;


//---- stub nested object --------------------------------------------------------------------------

MLuaUtil_Stub stub;


//---- skeleton management code area ---------------------------------------------------------------

int refcount;


void Retain ( )
{
	refcount++;
}


uint CountRef ( )
{
	return refcount;
}


void Release ( )
{
	if( refcount==1 )
		Destroy( this );
	else
		refcount--;
}


uint CountInterface ( )
{
	return MLuaUtil_count_interface();
}


bool EnumInterface ( uint i, su::classid* cid, pcstr* cname )
{
	return MLuaUtil_enum_interface(i,cid,cname);
}


su::IInterface* GetInterface ( classid cid )
{
	SU_IMPLEMENTS_MEMBER( ILuaUtil_i, cid );
	SU_IMPLEMENTS_MEMBER( ISwitch_i, cid );
	return NULL;
}


static MLuaUtil* Create( Pool* np, Pool* dp, AnyList* o )
{
	static MLuaUtil m;
	static bool yet = false;
	if( !yet )
	{
		m.refcount = 0;
		yet = true;
	}
	if( m.refcount==0 )
	{
		if( !m.stub.Init(dp,o) )
			return NULL;
	}
	m.refcount += 1;
	return &m;
}


static void Destroy( MLuaUtil* m )
{
	m->stub.Shut();
	m->refcount=0;
}

};

}




//==== builder =====================================================================================


SU_BEGIN_BUILDER( MLuaUtil )

su::classid GetMUID ( ) { return SIDL_IMPL_MUID; }
pcstr GetMClassname ( ) { return "MLuaUtil"; }
uint32 GetRevision ( ) { return SIDL_IMPL_REVISION; }
pcstr GetPackage ( ) { return SIDL_IMPL_PACKAGE; }
uint CountInterface ( ) { return MLuaUtil_count_interface(); }
bool EnumInterface ( uint i, su::classid* cid, pcstr* cname ) { return MLuaUtil_enum_interface(i,cid,cname); }
su::IInterface* FirstInterface ( void* base ) { return MLuaUtil_first_interface(base); }
su::IInterface* GetInterface ( void* base, su::classid cid ) { return MLuaUtil_get_interface(base,cid); }
su::IInterface* CreateObject( su::Pool* nestp, su::Pool* datap, su::AnyList* opts ) { return MLuaUtil_create_object(nestp,datap,opts); }
void* BaseToStub ( void* base ) { return MLuaUtil_base_to_stub(base); }
void* StubToBase ( void* base ) { return MLuaUtil_stub_to_base(base); }
uint CountSwitch ( ) { return MLuaUtil_count_switch(); }
bool EnumSwitch ( uint i, su::ISwitch::Desc& desc ) { return MLuaUtil_enum_switch(i,desc); }

SU_END_BUILDER( MLuaUtil )




//==== definitions =================================================================================


namespace {


su::IInterface* MLuaUtil_create_object( su::Pool* nestp, su::Pool* datap, su::AnyList* opts )
{
	MLuaUtil* m = MLuaUtil::Create( nestp, datap, opts );
	SU_REQUIRE_OR_NULL( m );
	return &m->ILuaUtil_i;
}


void* MLuaUtil_base_to_stub ( void* base )
{
	SU_REQUIRE_OR_NULL( base );
	return &(((MLuaUtil*)base)->stub);
}


void* MLuaUtil_stub_to_base ( void* stubp )
{
	SU_REQUIRE_OR_NULL( stubp );
	return SU_DELEGATE_BASEPTR(MLuaUtil,stub,stubp);
}


su::addin::Builder* MLuaUtil_builder ( )
{
	return &_builder_MLuaUtil;
}


uint MLuaUtil_count_interface ( )
{
	return 2;
}


bool MLuaUtil_enum_interface ( uint i, su::classid* cid, pcstr* cname )
{
	static const su::classid cids[] = { su::ILuaUtil::ClassId, su::ISwitch::ClassId };
	static const pcstr cnames[] = { "ILuaUtil", "ISwitch" };
	SU_REQUIRE_OR_FALSE( i<2 );
	if( cid )   *cid   = cids[i];
	if( cname ) *cname = cnames[i];
	return true;
}


su::IInterface* MLuaUtil_first_interface ( void* base )
{
	SU_REQUIRE_OR_NULL( base );
	return &(((MLuaUtil*)base)->ILuaUtil_i);
}


su::IInterface* MLuaUtil_get_interface ( void* base, su::classid cid )
{
	SU_REQUIRE_OR_NULL( base );
	return ((MLuaUtil*)base)->GetInterface(cid);
}


uint MLuaUtil_count_switch ( )
{
	return 83;
}


bool MLuaUtil_enum_switch ( uint i, su::ISwitch::Desc& desc )
{
	static su::ISwitch::Desc swdesc[] = {
		{ "hash32", "Lua_hash32", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "hash128", "Lua_hash128", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "sid", "Lua_sid", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "newBlob", "Lua_newBlob", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "newArray", "Lua_newArray", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "setConsoleFile", "Lua_setConsoleFile", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "getTime", "Lua_getTime", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "getDate", "Lua_getDate", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "getNow", "Lua_getNow", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "selectMap", "Lua_selectMap", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "binarizeMap", "Lua_binarizeMap", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "listMaps", "Lua_listMaps", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "listTags", "Lua_listTags", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "openPak", "Lua_openPak", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "getHeader", "LuaPak_getHeader", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "getDesc", "LuaPak_getDesc", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "enumDesc", "LuaPak_enumDesc", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "extractBytes", "LuaPak_extractBytes", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "extractRaw", "LuaPak_extractRaw", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "extractContent", "LuaPak_extractContent", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "startUpdating", "LuaPak_startUpdating", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "updateLabel", "LuaPak_updateLabel", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "updateRevision", "LuaPak_updateRevision", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "updateContent", "LuaPak_updateContent", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "endUpdating", "LuaPak_endUpdating", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "optimize", "LuaPak_optimize", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "gc", "LuaPak_gc", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "openZip", "Lua_openZip", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "len", "LuaZip_len", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "comment", "LuaZip_comment", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "tell", "LuaZip_tell", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "eof", "LuaZip_eof", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "firstFile", "LuaZip_firstFile", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "nextFile", "LuaZip_nextFile", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "seekFile", "LuaZip_seekFile", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "aboutCurrent", "LuaZip_aboutCurrent", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "openCurrent", "LuaZip_openCurrent", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "closeCurrent", "LuaZip_closeCurrent", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "readCurrent", "LuaZip_readCurrent", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "gc", "LuaZip_gc", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "newVector", "Lua_newVector", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "vcpy", "Lua_vcpy", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "veq", "Lua_veq", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "vlen", "Lua_vlen", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "vstr", "Lua_vstr", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "vlb", "Lua_vlb", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "vlh", "Lua_vlh", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "vlw", "Lua_vlw", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "vld", "Lua_vld", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "vlq", "Lua_vlq", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "vlf", "Lua_vlf", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "vsb", "Lua_vsb", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "vsh", "Lua_vsh", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "vsw", "Lua_vsw", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "vsd", "Lua_vsd", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "vsq", "Lua_vsq", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "vsf", "Lua_vsf", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "newCursor", "Lua_newCursor", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "size", "LuaCurs_size", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "pos", "LuaCurs_pos", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "seek", "LuaCurs_seek", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "backward", "LuaCurs_backward", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "hasbackward", "LuaCurs_hasbackward", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "gobackward", "LuaCurs_gobackward", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "forward", "LuaCurs_forward", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "hasforward", "LuaCurs_hasforward", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "goforward", "LuaCurs_goforward", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "align", "LuaCurs_align", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "uread", "LuaCurs_uread", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "sread", "LuaCurs_sread", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "sizeB", "LuaCurs_sizeB", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "seekB", "LuaCurs_seekB", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "usedB", "LuaCurs_usedB", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "leftB", "LuaCurs_leftB", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "findB", "LuaCurs_findB", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "writeu8", "LuaCurs_writeu8", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "writes8", "LuaCurs_writes8", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "writeu16", "LuaCurs_writeu16", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "writes16", "LuaCurs_writes16", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "writeu32", "LuaCurs_writeu32", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "writes32", "LuaCurs_writes32", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "writef32", "LuaCurs_writef32", "int,lua_State*", "wp", "ILuaUtil", NULL },
		{ "gc", "LuaCurs_gc", "int,lua_State*", "wp", "ILuaUtil", NULL },
		};
	SU_REQUIRE_OR_FALSE( i<83 );
	desc = swdesc[i];
	return true;
}


int MLuaUtil_find_switch ( pcstr inname=NULL )
{
	SU_REQUIRE_OR_NEG( inname && inname[0] );
	for( uint i=0 ; i<83 ; i++ ) {
		su::ISwitch::Desc d; MLuaUtil_enum_switch(i,d);
		if( util::Strequals(inname,d.name,false) )
			return i;
		}
	return -1;
}


bool MLuaUtil_call_switch_stack ( void* base, uint i, void* r, va_list args )
{
	SU_REQUIRE_OR_FALSE( base );
	SU_REQUIRE_OR_FALSE( i<83 );
	if( i==0 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.Lua_hash32(p0);
		return true;
	}
	if( i==1 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.Lua_hash128(p0);
		return true;
	}
	if( i==2 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.Lua_sid(p0);
		return true;
	}
	if( i==3 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.Lua_newBlob(p0);
		return true;
	}
	if( i==4 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.Lua_newArray(p0);
		return true;
	}
	if( i==5 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.Lua_setConsoleFile(p0);
		return true;
	}
	if( i==6 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.Lua_getTime(p0);
		return true;
	}
	if( i==7 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.Lua_getDate(p0);
		return true;
	}
	if( i==8 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.Lua_getNow(p0);
		return true;
	}
	if( i==9 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.Lua_selectMap(p0);
		return true;
	}
	if( i==10 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.Lua_binarizeMap(p0);
		return true;
	}
	if( i==11 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.Lua_listMaps(p0);
		return true;
	}
	if( i==12 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.Lua_listTags(p0);
		return true;
	}
	if( i==13 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.Lua_openPak(p0);
		return true;
	}
	if( i==14 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaPak_getHeader(p0);
		return true;
	}
	if( i==15 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaPak_getDesc(p0);
		return true;
	}
	if( i==16 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaPak_enumDesc(p0);
		return true;
	}
	if( i==17 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaPak_extractBytes(p0);
		return true;
	}
	if( i==18 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaPak_extractRaw(p0);
		return true;
	}
	if( i==19 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaPak_extractContent(p0);
		return true;
	}
	if( i==20 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaPak_startUpdating(p0);
		return true;
	}
	if( i==21 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaPak_updateLabel(p0);
		return true;
	}
	if( i==22 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaPak_updateRevision(p0);
		return true;
	}
	if( i==23 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaPak_updateContent(p0);
		return true;
	}
	if( i==24 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaPak_endUpdating(p0);
		return true;
	}
	if( i==25 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaPak_optimize(p0);
		return true;
	}
	if( i==26 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaPak_gc(p0);
		return true;
	}
	if( i==27 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.Lua_openZip(p0);
		return true;
	}
	if( i==28 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaZip_len(p0);
		return true;
	}
	if( i==29 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaZip_comment(p0);
		return true;
	}
	if( i==30 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaZip_tell(p0);
		return true;
	}
	if( i==31 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaZip_eof(p0);
		return true;
	}
	if( i==32 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaZip_firstFile(p0);
		return true;
	}
	if( i==33 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaZip_nextFile(p0);
		return true;
	}
	if( i==34 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaZip_seekFile(p0);
		return true;
	}
	if( i==35 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaZip_aboutCurrent(p0);
		return true;
	}
	if( i==36 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaZip_openCurrent(p0);
		return true;
	}
	if( i==37 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaZip_closeCurrent(p0);
		return true;
	}
	if( i==38 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaZip_readCurrent(p0);
		return true;
	}
	if( i==39 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaZip_gc(p0);
		return true;
	}
	if( i==40 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.Lua_newVector(p0);
		return true;
	}
	if( i==41 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.Lua_vcpy(p0);
		return true;
	}
	if( i==42 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.Lua_veq(p0);
		return true;
	}
	if( i==43 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.Lua_vlen(p0);
		return true;
	}
	if( i==44 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.Lua_vstr(p0);
		return true;
	}
	if( i==45 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.Lua_vlb(p0);
		return true;
	}
	if( i==46 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.Lua_vlh(p0);
		return true;
	}
	if( i==47 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.Lua_vlw(p0);
		return true;
	}
	if( i==48 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.Lua_vld(p0);
		return true;
	}
	if( i==49 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.Lua_vlq(p0);
		return true;
	}
	if( i==50 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.Lua_vlf(p0);
		return true;
	}
	if( i==51 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.Lua_vsb(p0);
		return true;
	}
	if( i==52 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.Lua_vsh(p0);
		return true;
	}
	if( i==53 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.Lua_vsw(p0);
		return true;
	}
	if( i==54 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.Lua_vsd(p0);
		return true;
	}
	if( i==55 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.Lua_vsq(p0);
		return true;
	}
	if( i==56 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.Lua_vsf(p0);
		return true;
	}
	if( i==57 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.Lua_newCursor(p0);
		return true;
	}
	if( i==58 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_size(p0);
		return true;
	}
	if( i==59 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_pos(p0);
		return true;
	}
	if( i==60 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_seek(p0);
		return true;
	}
	if( i==61 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_backward(p0);
		return true;
	}
	if( i==62 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_hasbackward(p0);
		return true;
	}
	if( i==63 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_gobackward(p0);
		return true;
	}
	if( i==64 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_forward(p0);
		return true;
	}
	if( i==65 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_hasforward(p0);
		return true;
	}
	if( i==66 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_goforward(p0);
		return true;
	}
	if( i==67 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_align(p0);
		return true;
	}
	if( i==68 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_uread(p0);
		return true;
	}
	if( i==69 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_sread(p0);
		return true;
	}
	if( i==70 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_sizeB(p0);
		return true;
	}
	if( i==71 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_seekB(p0);
		return true;
	}
	if( i==72 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_usedB(p0);
		return true;
	}
	if( i==73 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_leftB(p0);
		return true;
	}
	if( i==74 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_findB(p0);
		return true;
	}
	if( i==75 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_writeu8(p0);
		return true;
	}
	if( i==76 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_writes8(p0);
		return true;
	}
	if( i==77 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_writeu16(p0);
		return true;
	}
	if( i==78 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_writes16(p0);
		return true;
	}
	if( i==79 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_writeu32(p0);
		return true;
	}
	if( i==80 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_writes32(p0);
		return true;
	}
	if( i==81 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_writef32(p0);
		return true;
	}
	if( i==82 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_gc(p0);
		return true;
	}
	return false;
}


bool MLuaUtil_call_switch_mem ( void* base, uint i, Any* r, int argc, Any* argv )
{
	SU_REQUIRE_OR_FALSE( base );
	SU_REQUIRE_OR_FALSE( i<83 );
	if( i==0 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.Lua_hash32(p0) );
		return true;
	}
	if( i==1 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.Lua_hash128(p0) );
		return true;
	}
	if( i==2 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.Lua_sid(p0) );
		return true;
	}
	if( i==3 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.Lua_newBlob(p0) );
		return true;
	}
	if( i==4 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.Lua_newArray(p0) );
		return true;
	}
	if( i==5 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.Lua_setConsoleFile(p0) );
		return true;
	}
	if( i==6 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.Lua_getTime(p0) );
		return true;
	}
	if( i==7 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.Lua_getDate(p0) );
		return true;
	}
	if( i==8 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.Lua_getNow(p0) );
		return true;
	}
	if( i==9 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.Lua_selectMap(p0) );
		return true;
	}
	if( i==10 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.Lua_binarizeMap(p0) );
		return true;
	}
	if( i==11 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.Lua_listMaps(p0) );
		return true;
	}
	if( i==12 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.Lua_listTags(p0) );
		return true;
	}
	if( i==13 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.Lua_openPak(p0) );
		return true;
	}
	if( i==14 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaPak_getHeader(p0) );
		return true;
	}
	if( i==15 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaPak_getDesc(p0) );
		return true;
	}
	if( i==16 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaPak_enumDesc(p0) );
		return true;
	}
	if( i==17 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaPak_extractBytes(p0) );
		return true;
	}
	if( i==18 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaPak_extractRaw(p0) );
		return true;
	}
	if( i==19 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaPak_extractContent(p0) );
		return true;
	}
	if( i==20 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaPak_startUpdating(p0) );
		return true;
	}
	if( i==21 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaPak_updateLabel(p0) );
		return true;
	}
	if( i==22 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaPak_updateRevision(p0) );
		return true;
	}
	if( i==23 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaPak_updateContent(p0) );
		return true;
	}
	if( i==24 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaPak_endUpdating(p0) );
		return true;
	}
	if( i==25 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaPak_optimize(p0) );
		return true;
	}
	if( i==26 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaPak_gc(p0) );
		return true;
	}
	if( i==27 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.Lua_openZip(p0) );
		return true;
	}
	if( i==28 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaZip_len(p0) );
		return true;
	}
	if( i==29 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaZip_comment(p0) );
		return true;
	}
	if( i==30 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaZip_tell(p0) );
		return true;
	}
	if( i==31 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaZip_eof(p0) );
		return true;
	}
	if( i==32 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaZip_firstFile(p0) );
		return true;
	}
	if( i==33 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaZip_nextFile(p0) );
		return true;
	}
	if( i==34 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaZip_seekFile(p0) );
		return true;
	}
	if( i==35 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaZip_aboutCurrent(p0) );
		return true;
	}
	if( i==36 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaZip_openCurrent(p0) );
		return true;
	}
	if( i==37 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaZip_closeCurrent(p0) );
		return true;
	}
	if( i==38 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaZip_readCurrent(p0) );
		return true;
	}
	if( i==39 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaZip_gc(p0) );
		return true;
	}
	if( i==40 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.Lua_newVector(p0) );
		return true;
	}
	if( i==41 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.Lua_vcpy(p0) );
		return true;
	}
	if( i==42 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.Lua_veq(p0) );
		return true;
	}
	if( i==43 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.Lua_vlen(p0) );
		return true;
	}
	if( i==44 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.Lua_vstr(p0) );
		return true;
	}
	if( i==45 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.Lua_vlb(p0) );
		return true;
	}
	if( i==46 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.Lua_vlh(p0) );
		return true;
	}
	if( i==47 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.Lua_vlw(p0) );
		return true;
	}
	if( i==48 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.Lua_vld(p0) );
		return true;
	}
	if( i==49 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.Lua_vlq(p0) );
		return true;
	}
	if( i==50 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.Lua_vlf(p0) );
		return true;
	}
	if( i==51 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.Lua_vsb(p0) );
		return true;
	}
	if( i==52 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.Lua_vsh(p0) );
		return true;
	}
	if( i==53 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.Lua_vsw(p0) );
		return true;
	}
	if( i==54 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.Lua_vsd(p0) );
		return true;
	}
	if( i==55 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.Lua_vsq(p0) );
		return true;
	}
	if( i==56 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.Lua_vsf(p0) );
		return true;
	}
	if( i==57 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.Lua_newCursor(p0) );
		return true;
	}
	if( i==58 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_size(p0) );
		return true;
	}
	if( i==59 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_pos(p0) );
		return true;
	}
	if( i==60 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_seek(p0) );
		return true;
	}
	if( i==61 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_backward(p0) );
		return true;
	}
	if( i==62 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_hasbackward(p0) );
		return true;
	}
	if( i==63 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_gobackward(p0) );
		return true;
	}
	if( i==64 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_forward(p0) );
		return true;
	}
	if( i==65 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_hasforward(p0) );
		return true;
	}
	if( i==66 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_goforward(p0) );
		return true;
	}
	if( i==67 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_align(p0) );
		return true;
	}
	if( i==68 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_uread(p0) );
		return true;
	}
	if( i==69 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_sread(p0) );
		return true;
	}
	if( i==70 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_sizeB(p0) );
		return true;
	}
	if( i==71 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_seekB(p0) );
		return true;
	}
	if( i==72 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_usedB(p0) );
		return true;
	}
	if( i==73 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_leftB(p0) );
		return true;
	}
	if( i==74 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_findB(p0) );
		return true;
	}
	if( i==75 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_writeu8(p0) );
		return true;
	}
	if( i==76 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_writes8(p0) );
		return true;
	}
	if( i==77 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_writeu16(p0) );
		return true;
	}
	if( i==78 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_writes16(p0) );
		return true;
	}
	if( i==79 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_writeu32(p0) );
		return true;
	}
	if( i==80 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_writes32(p0) );
		return true;
	}
	if( i==81 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_writef32(p0) );
		return true;
	}
	if( i==82 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaUtil*)base)->ILuaUtil_i.LuaCurs_gc(p0) );
		return true;
	}
	return false;
}


}


// !! This file has been automatically generated by the sugar sidl tool.
// !! Do not edit this file manually under risk of losing your changes.

