/*LIC-HDR********************************************************************
**
** Copyright (C) 2005-2011 AtOnce Technologies
**
** This file is part of the Sugar core-system framework.
**
** This file and the associated product may be used and distributed
** under the terms of a current License as defined by AtOnce Technologies
** and appearing in the file LICENSE.TXT included in the packaging of this file.
**
** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
**
** See http://www.atonce-technologies.com or email info@atonce-technologies.com
** for informations about Sugar Framework and AtOnce Technologies others products
** License Agreements.
**
** Contact info@atonce-technologies.com if any conditions of this license
** are not clear to you.
**
*****************************************************************LIC-HDR*/


// !! This file has been automatically generated by the sugar sidl tool.
// !! Do not edit this file manually under risk of losing your changes.


//==== includes ====================================================================================

#include <sufw/precompiled/supch_core.h>
#include "..\..\core\base\su_iinterface.h"
#include "su_iluamath.h"
#include "..\..\core\base\su_iswitch.h"
#include <stdarg.h>




//==== defines =====================================================================================

#ifndef SIDL_IMPL_CLASSNAME
#define SIDL_IMPL_CLASSNAME MLuaMath
#endif

#ifndef SIDL_IMPL_MUID
#define SIDL_IMPL_MUID 0xd337c900u
#endif

#ifndef SIDL_IMPL_QUALIFIER
#define SIDL_IMPL_QUALIFIER static
#endif

#ifndef SIDL_IMPL_IS_STATIC
#define SIDL_IMPL_IS_STATIC 
#endif

#ifndef SIDL_IMPL_SWITCHED
#define SIDL_IMPL_SWITCHED 
#endif

#ifndef SIDL_IMPL_REVISION
#define SIDL_IMPL_REVISION 0
#endif

#ifndef SIDL_IMPL_PACKAGE
#define SIDL_IMPL_PACKAGE "su.fw.lang"
#endif

#ifndef SIDL_IMPL_ATTR_V
#define SIDL_IMPL_ATTR_V NULL
#endif

#ifndef SIDL_IMPL_ATTR_C
#define SIDL_IMPL_ATTR_C 0
#endif

#ifndef SIDL_STUB_CLASSNAME
#define SIDL_STUB_CLASSNAME MLuaMath_Stub
#endif

#ifndef SIDL_IMPL_INTERFACE
#define SIDL_IMPL_INTERFACE(I) ((I*)MLuaMath_get_interface(MLuaMath_stub_to_base(this),I::ClassId))
#endif


//==== declarations ================================================================================

namespace {

su::IInterface* MLuaMath_create_object( su::Pool*, su::Pool*, su::AnyList* );
void* MLuaMath_base_to_stub ( void* );
void* MLuaMath_stub_to_base ( void* );
su::addin::Builder* MLuaMath_builder ( );
uint MLuaMath_count_interface ( );
bool MLuaMath_enum_interface ( uint, su::classid*, pcstr* );
su::IInterface* MLuaMath_first_interface ( void* );
su::IInterface* MLuaMath_get_interface ( void*, su::classid );
uint MLuaMath_count_switch ( );
bool MLuaMath_enum_switch ( uint, su::ISwitch::Desc& );
int MLuaMath_find_switch ( pcstr );
bool MLuaMath_call_switch_stack ( void*, uint, void*, va_list );
bool MLuaMath_call_switch_mem ( void*, uint, su::Any*, int, su::Any* );

}


//==== stub area ===================================================================================

#undef  SIDL_PROPER
#undef  SIDL_STUB
#undef  SIDL_BUILDER
#undef  SIDL_CODE
#define SIDL_STUB
#include "su_mluamath_stub.h"




//==== skeleton ====================================================================================

namespace {


struct MLuaMath
{

//---- bridges -------------------------------------------------------------------------------------

struct ILuaMath_t : public su::ILuaMath {
	// from IInterface
	::su::classbase         GetBase            (  ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return &(*m); }
	::su::addin::Builder *  GetBuilder         (  ) { return MLuaMath_builder(); }
	void                    Retain             (  ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); (*m).Retain(); }
	::uint                  CountRef           (  ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (*m).CountRef(); }
	void                    Release            (  ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); (*m).Release(); }
	::uint                  CountInterface     (  ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (*m).CountInterface(); }
	bool                    EnumInterface      ( ::uint p0,::su::classid * p1,::pcstr * p2 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (*m).EnumInterface(p0,p1,p2); }
	::su::IInterface *      GetInterface       ( ::su::classid p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (*m).GetInterface(p0); }
	// from ILuaMath
	int                     Lua_rand           ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_rand(p0); }
	int                     Lua_srand          ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_srand(p0); }
	int                     Lua_cos            ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_cos(p0); }
	int                     Lua_sin            ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_sin(p0); }
	int                     Lua_tan            ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_tan(p0); }
	int                     Lua_sqrt           ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_sqrt(p0); }
	int                     Lua_newVec2        ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_newVec2(p0); }
	int                     LuaVec2_x          ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).LuaVec2_x(p0); }
	int                     LuaVec2_y          ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).LuaVec2_y(p0); }
	int                     LuaVec2_yx         ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).LuaVec2_yx(p0); }
	int                     LuaVec2_asTable    ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).LuaVec2_asTable(p0); }
	int                     Lua_newVec3        ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_newVec3(p0); }
	int                     LuaVec3_x          ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).LuaVec3_x(p0); }
	int                     LuaVec3_y          ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).LuaVec3_y(p0); }
	int                     LuaVec3_z          ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).LuaVec3_z(p0); }
	int                     LuaVec3_xzy        ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).LuaVec3_xzy(p0); }
	int                     LuaVec3_yxz        ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).LuaVec3_yxz(p0); }
	int                     LuaVec3_yzx        ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).LuaVec3_yzx(p0); }
	int                     LuaVec3_zxy        ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).LuaVec3_zxy(p0); }
	int                     LuaVec3_zyx        ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).LuaVec3_zyx(p0); }
	int                     LuaVec3_asTable    ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).LuaVec3_asTable(p0); }
	int                     Lua_newVec4        ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_newVec4(p0); }
	int                     LuaVec4_x          ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).LuaVec4_x(p0); }
	int                     LuaVec4_y          ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).LuaVec4_y(p0); }
	int                     LuaVec4_z          ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).LuaVec4_z(p0); }
	int                     LuaVec4_w          ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).LuaVec4_w(p0); }
	int                     LuaVec4_asTable    ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).LuaVec4_asTable(p0); }
	int                     Lua_newQuat        ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_newQuat(p0); }
	int                     LuaQuat_x          ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).LuaQuat_x(p0); }
	int                     LuaQuat_y          ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).LuaQuat_y(p0); }
	int                     LuaQuat_z          ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).LuaQuat_z(p0); }
	int                     LuaQuat_w          ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).LuaQuat_w(p0); }
	int                     LuaQuat_xzyw       ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).LuaQuat_xzyw(p0); }
	int                     LuaQuat_asTable    ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).LuaQuat_asTable(p0); }
	int                     Lua_newMatrix      ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_newMatrix(p0); }
	int                     LuaMat_get         ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).LuaMat_get(p0); }
	int                     LuaMat_set         ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).LuaMat_set(p0); }
	int                     LuaMat_asTable     ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).LuaMat_asTable(p0); }
	int                     Lua_copy           ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_copy(p0); }
	int                     Lua_zero           ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_zero(p0); }
	int                     Lua_identity       ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_identity(p0); }
	int                     Lua_isIdentity     ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_isIdentity(p0); }
	int                     Lua_norm           ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_norm(p0); }
	int                     Lua_norm2          ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_norm2(p0); }
	int                     Lua_normalize      ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_normalize(p0); }
	int                     Lua_orthoNormalize ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_orthoNormalize(p0); }
	int                     Lua_cross          ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_cross(p0); }
	int                     Lua_dot            ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_dot(p0); }
	int                     Lua_near           ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_near(p0); }
	int                     Lua_add            ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_add(p0); }
	int                     Lua_sub            ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_sub(p0); }
	int                     Lua_mul            ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_mul(p0); }
	int                     Lua_min            ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_min(p0); }
	int                     Lua_max            ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_max(p0); }
	int                     Lua_scale          ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_scale(p0); }
	int                     Lua_apply          ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_apply(p0); }
	int                     Lua_applyVector    ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_applyVector(p0); }
	int                     Lua_lerp           ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_lerp(p0); }
	int                     Lua_slerp          ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_slerp(p0); }
	int                     Lua_inverse        ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_inverse(p0); }
	int                     Lua_fastInverse    ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_fastInverse(p0); }
	int                     Lua_translate      ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_translate(p0); }
	int                     Lua_preTranslate   ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_preTranslate(p0); }
	int                     Lua_rotate         ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_rotate(p0); }
	int                     Lua_preRotate      ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_preRotate(p0); }
	int                     Lua_rotateX        ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_rotateX(p0); }
	int                     Lua_rotateY        ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_rotateY(p0); }
	int                     Lua_rotateZ        ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_rotateZ(p0); }
	int                     Lua_preRotateX     ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_preRotateX(p0); }
	int                     Lua_preRotateY     ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_preRotateY(p0); }
	int                     Lua_preRotateZ     ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_preRotateZ(p0); }
	int                     Lua_preScale       ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_preScale(p0); }
	int                     Lua_translation    ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_translation(p0); }
	int                     Lua_rotationX      ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_rotationX(p0); }
	int                     Lua_rotationY      ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_rotationY(p0); }
	int                     Lua_rotationZ      ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_rotationZ(p0); }
	int                     Lua_rotation       ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_rotation(p0); }
	int                     Lua_scaling        ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_scaling(p0); }
	int                     Lua_buildTR        ( lua_State* p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ILuaMath_i,this); return (m->stub).Lua_buildTR(p0); }
} ILuaMath_i;


struct ISwitch_t : public su::ISwitch {
	// from IInterface
	::su::classbase         GetBase        (  ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ISwitch_i,this); return &(*m); }
	::su::addin::Builder *  GetBuilder     (  ) { return MLuaMath_builder(); }
	void                    Retain         (  ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ISwitch_i,this); (*m).Retain(); }
	::uint                  CountRef       (  ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ISwitch_i,this); return (*m).CountRef(); }
	void                    Release        (  ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ISwitch_i,this); (*m).Release(); }
	::uint                  CountInterface (  ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ISwitch_i,this); return (*m).CountInterface(); }
	bool                    EnumInterface  ( ::uint p0,::su::classid * p1,::pcstr * p2 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ISwitch_i,this); return (*m).EnumInterface(p0,p1,p2); }
	::su::IInterface *      GetInterface   ( ::su::classid p0 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ISwitch_i,this); return (*m).GetInterface(p0); }
	// from ISwitch
	::uint                  CountSwitch    (  ) { return MLuaMath_count_switch(); }
	bool                    EnumSwitch     ( ::uint p0,::su::ISwitch::Desc & p1 ) { return MLuaMath_enum_switch(p0,p1); }
	int                     FindSwitch     ( ::pcstr p0 ) { return MLuaMath_find_switch(p0); }
	bool                    CallSwitch     ( ::uint p0,void * p1,... ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ISwitch_i,this); va_list vl; va_start(vl,p1); return MLuaMath_call_switch_stack(m,p0,p1,vl); va_end(vl); }
	bool                    CallSwitchMem  ( ::uint p0,::su::Any * p1,int p2,::su::Any * p3 ) { MLuaMath* m = SU_DELEGATE_BASEPTR(MLuaMath,ISwitch_i,this); return MLuaMath_call_switch_mem(m,p0,p1,p2,p3); }
} ISwitch_i;


//---- stub nested object --------------------------------------------------------------------------

MLuaMath_Stub stub;


//---- skeleton management code area ---------------------------------------------------------------

int refcount;


void Retain ( )
{
	refcount++;
}


uint CountRef ( )
{
	return refcount;
}


void Release ( )
{
	if( refcount==1 )
		Destroy( this );
	else
		refcount--;
}


uint CountInterface ( )
{
	return MLuaMath_count_interface();
}


bool EnumInterface ( uint i, su::classid* cid, pcstr* cname )
{
	return MLuaMath_enum_interface(i,cid,cname);
}


su::IInterface* GetInterface ( classid cid )
{
	SU_IMPLEMENTS_MEMBER( ILuaMath_i, cid );
	SU_IMPLEMENTS_MEMBER( ISwitch_i, cid );
	return NULL;
}


static MLuaMath* Create( Pool* np, Pool* dp, AnyList* o )
{
	static MLuaMath m;
	static bool yet = false;
	if( !yet )
	{
		m.refcount = 0;
		yet = true;
	}
	if( m.refcount==0 )
	{
		if( !m.stub.Init(dp,o) )
			return NULL;
	}
	m.refcount += 1;
	return &m;
}


static void Destroy( MLuaMath* m )
{
	m->stub.Shut();
	m->refcount=0;
}

};

}




//==== builder =====================================================================================


SU_BEGIN_BUILDER( MLuaMath )

su::classid GetMUID ( ) { return SIDL_IMPL_MUID; }
pcstr GetMClassname ( ) { return "MLuaMath"; }
uint32 GetRevision ( ) { return SIDL_IMPL_REVISION; }
pcstr GetPackage ( ) { return SIDL_IMPL_PACKAGE; }
uint CountInterface ( ) { return MLuaMath_count_interface(); }
bool EnumInterface ( uint i, su::classid* cid, pcstr* cname ) { return MLuaMath_enum_interface(i,cid,cname); }
su::IInterface* FirstInterface ( void* base ) { return MLuaMath_first_interface(base); }
su::IInterface* GetInterface ( void* base, su::classid cid ) { return MLuaMath_get_interface(base,cid); }
su::IInterface* CreateObject( su::Pool* nestp, su::Pool* datap, su::AnyList* opts ) { return MLuaMath_create_object(nestp,datap,opts); }
void* BaseToStub ( void* base ) { return MLuaMath_base_to_stub(base); }
void* StubToBase ( void* base ) { return MLuaMath_stub_to_base(base); }
uint CountSwitch ( ) { return MLuaMath_count_switch(); }
bool EnumSwitch ( uint i, su::ISwitch::Desc& desc ) { return MLuaMath_enum_switch(i,desc); }

SU_END_BUILDER( MLuaMath )




//==== definitions =================================================================================


namespace {


su::IInterface* MLuaMath_create_object( su::Pool* nestp, su::Pool* datap, su::AnyList* opts )
{
	MLuaMath* m = MLuaMath::Create( nestp, datap, opts );
	SU_REQUIRE_OR_NULL( m );
	return &m->ILuaMath_i;
}


void* MLuaMath_base_to_stub ( void* base )
{
	SU_REQUIRE_OR_NULL( base );
	return &(((MLuaMath*)base)->stub);
}


void* MLuaMath_stub_to_base ( void* stubp )
{
	SU_REQUIRE_OR_NULL( stubp );
	return SU_DELEGATE_BASEPTR(MLuaMath,stub,stubp);
}


su::addin::Builder* MLuaMath_builder ( )
{
	return &_builder_MLuaMath;
}


uint MLuaMath_count_interface ( )
{
	return 2;
}


bool MLuaMath_enum_interface ( uint i, su::classid* cid, pcstr* cname )
{
	static const su::classid cids[] = { su::ILuaMath::ClassId, su::ISwitch::ClassId };
	static const pcstr cnames[] = { "ILuaMath", "ISwitch" };
	SU_REQUIRE_OR_FALSE( i<2 );
	if( cid )   *cid   = cids[i];
	if( cname ) *cname = cnames[i];
	return true;
}


su::IInterface* MLuaMath_first_interface ( void* base )
{
	SU_REQUIRE_OR_NULL( base );
	return &(((MLuaMath*)base)->ILuaMath_i);
}


su::IInterface* MLuaMath_get_interface ( void* base, su::classid cid )
{
	SU_REQUIRE_OR_NULL( base );
	return ((MLuaMath*)base)->GetInterface(cid);
}


uint MLuaMath_count_switch ( )
{
	return 79;
}


bool MLuaMath_enum_switch ( uint i, su::ISwitch::Desc& desc )
{
	static su::ISwitch::Desc swdesc[] = {
		{ "rand", "Lua_rand", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "srand", "Lua_srand", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "cos", "Lua_cos", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "sin", "Lua_sin", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "tan", "Lua_tan", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "sqrt", "Lua_sqrt", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "newVec2", "Lua_newVec2", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "x", "LuaVec2_x", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "y", "LuaVec2_y", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "yx", "LuaVec2_yx", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "asTable", "LuaVec2_asTable", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "newVec3", "Lua_newVec3", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "x", "LuaVec3_x", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "y", "LuaVec3_y", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "z", "LuaVec3_z", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "xzy", "LuaVec3_xzy", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "yxz", "LuaVec3_yxz", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "yzx", "LuaVec3_yzx", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "zxy", "LuaVec3_zxy", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "zyx", "LuaVec3_zyx", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "asTable", "LuaVec3_asTable", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "newVec4", "Lua_newVec4", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "x", "LuaVec4_x", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "y", "LuaVec4_y", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "z", "LuaVec4_z", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "w", "LuaVec4_w", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "asTable", "LuaVec4_asTable", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "newQuat", "Lua_newQuat", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "x", "LuaQuat_x", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "y", "LuaQuat_y", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "z", "LuaQuat_z", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "w", "LuaQuat_w", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "xzyw", "LuaQuat_xzyw", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "asTable", "LuaQuat_asTable", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "newMatrix", "Lua_newMatrix", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "get", "LuaMat_get", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "set", "LuaMat_set", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "asTable", "LuaMat_asTable", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "copy", "Lua_copy", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "zero", "Lua_zero", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "identity", "Lua_identity", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "isIdentity", "Lua_isIdentity", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "norm", "Lua_norm", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "norm2", "Lua_norm2", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "normalize", "Lua_normalize", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "orthoNormalize", "Lua_orthoNormalize", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "cross", "Lua_cross", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "dot", "Lua_dot", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "near", "Lua_near", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "add", "Lua_add", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "sub", "Lua_sub", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "mul", "Lua_mul", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "min", "Lua_min", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "max", "Lua_max", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "scale", "Lua_scale", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "apply", "Lua_apply", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "applyVector", "Lua_applyVector", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "lerp", "Lua_lerp", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "slerp", "Lua_slerp", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "inverse", "Lua_inverse", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "fastInverse", "Lua_fastInverse", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "translate", "Lua_translate", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "preTranslate", "Lua_preTranslate", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "rotate", "Lua_rotate", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "preRotate", "Lua_preRotate", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "rotateX", "Lua_rotateX", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "rotateY", "Lua_rotateY", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "rotateZ", "Lua_rotateZ", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "preRotateX", "Lua_preRotateX", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "preRotateY", "Lua_preRotateY", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "preRotateZ", "Lua_preRotateZ", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "preScale", "Lua_preScale", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "translation", "Lua_translation", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "rotationX", "Lua_rotationX", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "rotationY", "Lua_rotationY", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "rotationZ", "Lua_rotationZ", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "rotation", "Lua_rotation", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "scaling", "Lua_scaling", "int,lua_State*", "wp", "ILuaMath", NULL },
		{ "buildTR", "Lua_buildTR", "int,lua_State*", "wp", "ILuaMath", NULL },
		};
	SU_REQUIRE_OR_FALSE( i<79 );
	desc = swdesc[i];
	return true;
}


int MLuaMath_find_switch ( pcstr inname=NULL )
{
	SU_REQUIRE_OR_NEG( inname && inname[0] );
	for( uint i=0 ; i<79 ; i++ ) {
		su::ISwitch::Desc d; MLuaMath_enum_switch(i,d);
		if( util::Strequals(inname,d.name,false) )
			return i;
		}
	return -1;
}


bool MLuaMath_call_switch_stack ( void* base, uint i, void* r, va_list args )
{
	SU_REQUIRE_OR_FALSE( base );
	SU_REQUIRE_OR_FALSE( i<79 );
	if( i==0 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_rand(p0);
		return true;
	}
	if( i==1 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_srand(p0);
		return true;
	}
	if( i==2 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_cos(p0);
		return true;
	}
	if( i==3 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_sin(p0);
		return true;
	}
	if( i==4 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_tan(p0);
		return true;
	}
	if( i==5 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_sqrt(p0);
		return true;
	}
	if( i==6 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_newVec2(p0);
		return true;
	}
	if( i==7 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.LuaVec2_x(p0);
		return true;
	}
	if( i==8 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.LuaVec2_y(p0);
		return true;
	}
	if( i==9 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.LuaVec2_yx(p0);
		return true;
	}
	if( i==10 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.LuaVec2_asTable(p0);
		return true;
	}
	if( i==11 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_newVec3(p0);
		return true;
	}
	if( i==12 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.LuaVec3_x(p0);
		return true;
	}
	if( i==13 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.LuaVec3_y(p0);
		return true;
	}
	if( i==14 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.LuaVec3_z(p0);
		return true;
	}
	if( i==15 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.LuaVec3_xzy(p0);
		return true;
	}
	if( i==16 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.LuaVec3_yxz(p0);
		return true;
	}
	if( i==17 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.LuaVec3_yzx(p0);
		return true;
	}
	if( i==18 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.LuaVec3_zxy(p0);
		return true;
	}
	if( i==19 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.LuaVec3_zyx(p0);
		return true;
	}
	if( i==20 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.LuaVec3_asTable(p0);
		return true;
	}
	if( i==21 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_newVec4(p0);
		return true;
	}
	if( i==22 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.LuaVec4_x(p0);
		return true;
	}
	if( i==23 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.LuaVec4_y(p0);
		return true;
	}
	if( i==24 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.LuaVec4_z(p0);
		return true;
	}
	if( i==25 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.LuaVec4_w(p0);
		return true;
	}
	if( i==26 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.LuaVec4_asTable(p0);
		return true;
	}
	if( i==27 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_newQuat(p0);
		return true;
	}
	if( i==28 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.LuaQuat_x(p0);
		return true;
	}
	if( i==29 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.LuaQuat_y(p0);
		return true;
	}
	if( i==30 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.LuaQuat_z(p0);
		return true;
	}
	if( i==31 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.LuaQuat_w(p0);
		return true;
	}
	if( i==32 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.LuaQuat_xzyw(p0);
		return true;
	}
	if( i==33 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.LuaQuat_asTable(p0);
		return true;
	}
	if( i==34 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_newMatrix(p0);
		return true;
	}
	if( i==35 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.LuaMat_get(p0);
		return true;
	}
	if( i==36 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.LuaMat_set(p0);
		return true;
	}
	if( i==37 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.LuaMat_asTable(p0);
		return true;
	}
	if( i==38 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_copy(p0);
		return true;
	}
	if( i==39 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_zero(p0);
		return true;
	}
	if( i==40 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_identity(p0);
		return true;
	}
	if( i==41 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_isIdentity(p0);
		return true;
	}
	if( i==42 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_norm(p0);
		return true;
	}
	if( i==43 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_norm2(p0);
		return true;
	}
	if( i==44 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_normalize(p0);
		return true;
	}
	if( i==45 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_orthoNormalize(p0);
		return true;
	}
	if( i==46 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_cross(p0);
		return true;
	}
	if( i==47 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_dot(p0);
		return true;
	}
	if( i==48 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_near(p0);
		return true;
	}
	if( i==49 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_add(p0);
		return true;
	}
	if( i==50 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_sub(p0);
		return true;
	}
	if( i==51 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_mul(p0);
		return true;
	}
	if( i==52 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_min(p0);
		return true;
	}
	if( i==53 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_max(p0);
		return true;
	}
	if( i==54 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_scale(p0);
		return true;
	}
	if( i==55 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_apply(p0);
		return true;
	}
	if( i==56 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_applyVector(p0);
		return true;
	}
	if( i==57 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_lerp(p0);
		return true;
	}
	if( i==58 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_slerp(p0);
		return true;
	}
	if( i==59 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_inverse(p0);
		return true;
	}
	if( i==60 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_fastInverse(p0);
		return true;
	}
	if( i==61 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_translate(p0);
		return true;
	}
	if( i==62 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_preTranslate(p0);
		return true;
	}
	if( i==63 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_rotate(p0);
		return true;
	}
	if( i==64 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_preRotate(p0);
		return true;
	}
	if( i==65 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_rotateX(p0);
		return true;
	}
	if( i==66 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_rotateY(p0);
		return true;
	}
	if( i==67 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_rotateZ(p0);
		return true;
	}
	if( i==68 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_preRotateX(p0);
		return true;
	}
	if( i==69 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_preRotateY(p0);
		return true;
	}
	if( i==70 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_preRotateZ(p0);
		return true;
	}
	if( i==71 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_preScale(p0);
		return true;
	}
	if( i==72 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_translation(p0);
		return true;
	}
	if( i==73 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_rotationX(p0);
		return true;
	}
	if( i==74 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_rotationY(p0);
		return true;
	}
	if( i==75 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_rotationZ(p0);
		return true;
	}
	if( i==76 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_rotation(p0);
		return true;
	}
	if( i==77 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_scaling(p0);
		return true;
	}
	if( i==78 ) {
		SU_ASSERT( r );
		lua_State* p0 = va_arg(args,lua_State*);
		*((int*)r) = ((MLuaMath*)base)->ILuaMath_i.Lua_buildTR(p0);
		return true;
	}
	return false;
}


bool MLuaMath_call_switch_mem ( void* base, uint i, Any* r, int argc, Any* argv )
{
	SU_REQUIRE_OR_FALSE( base );
	SU_REQUIRE_OR_FALSE( i<79 );
	if( i==0 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_rand(p0) );
		return true;
	}
	if( i==1 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_srand(p0) );
		return true;
	}
	if( i==2 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_cos(p0) );
		return true;
	}
	if( i==3 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_sin(p0) );
		return true;
	}
	if( i==4 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_tan(p0) );
		return true;
	}
	if( i==5 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_sqrt(p0) );
		return true;
	}
	if( i==6 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_newVec2(p0) );
		return true;
	}
	if( i==7 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.LuaVec2_x(p0) );
		return true;
	}
	if( i==8 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.LuaVec2_y(p0) );
		return true;
	}
	if( i==9 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.LuaVec2_yx(p0) );
		return true;
	}
	if( i==10 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.LuaVec2_asTable(p0) );
		return true;
	}
	if( i==11 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_newVec3(p0) );
		return true;
	}
	if( i==12 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.LuaVec3_x(p0) );
		return true;
	}
	if( i==13 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.LuaVec3_y(p0) );
		return true;
	}
	if( i==14 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.LuaVec3_z(p0) );
		return true;
	}
	if( i==15 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.LuaVec3_xzy(p0) );
		return true;
	}
	if( i==16 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.LuaVec3_yxz(p0) );
		return true;
	}
	if( i==17 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.LuaVec3_yzx(p0) );
		return true;
	}
	if( i==18 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.LuaVec3_zxy(p0) );
		return true;
	}
	if( i==19 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.LuaVec3_zyx(p0) );
		return true;
	}
	if( i==20 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.LuaVec3_asTable(p0) );
		return true;
	}
	if( i==21 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_newVec4(p0) );
		return true;
	}
	if( i==22 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.LuaVec4_x(p0) );
		return true;
	}
	if( i==23 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.LuaVec4_y(p0) );
		return true;
	}
	if( i==24 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.LuaVec4_z(p0) );
		return true;
	}
	if( i==25 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.LuaVec4_w(p0) );
		return true;
	}
	if( i==26 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.LuaVec4_asTable(p0) );
		return true;
	}
	if( i==27 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_newQuat(p0) );
		return true;
	}
	if( i==28 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.LuaQuat_x(p0) );
		return true;
	}
	if( i==29 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.LuaQuat_y(p0) );
		return true;
	}
	if( i==30 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.LuaQuat_z(p0) );
		return true;
	}
	if( i==31 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.LuaQuat_w(p0) );
		return true;
	}
	if( i==32 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.LuaQuat_xzyw(p0) );
		return true;
	}
	if( i==33 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.LuaQuat_asTable(p0) );
		return true;
	}
	if( i==34 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_newMatrix(p0) );
		return true;
	}
	if( i==35 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.LuaMat_get(p0) );
		return true;
	}
	if( i==36 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.LuaMat_set(p0) );
		return true;
	}
	if( i==37 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.LuaMat_asTable(p0) );
		return true;
	}
	if( i==38 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_copy(p0) );
		return true;
	}
	if( i==39 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_zero(p0) );
		return true;
	}
	if( i==40 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_identity(p0) );
		return true;
	}
	if( i==41 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_isIdentity(p0) );
		return true;
	}
	if( i==42 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_norm(p0) );
		return true;
	}
	if( i==43 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_norm2(p0) );
		return true;
	}
	if( i==44 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_normalize(p0) );
		return true;
	}
	if( i==45 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_orthoNormalize(p0) );
		return true;
	}
	if( i==46 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_cross(p0) );
		return true;
	}
	if( i==47 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_dot(p0) );
		return true;
	}
	if( i==48 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_near(p0) );
		return true;
	}
	if( i==49 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_add(p0) );
		return true;
	}
	if( i==50 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_sub(p0) );
		return true;
	}
	if( i==51 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_mul(p0) );
		return true;
	}
	if( i==52 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_min(p0) );
		return true;
	}
	if( i==53 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_max(p0) );
		return true;
	}
	if( i==54 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_scale(p0) );
		return true;
	}
	if( i==55 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_apply(p0) );
		return true;
	}
	if( i==56 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_applyVector(p0) );
		return true;
	}
	if( i==57 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_lerp(p0) );
		return true;
	}
	if( i==58 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_slerp(p0) );
		return true;
	}
	if( i==59 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_inverse(p0) );
		return true;
	}
	if( i==60 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_fastInverse(p0) );
		return true;
	}
	if( i==61 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_translate(p0) );
		return true;
	}
	if( i==62 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_preTranslate(p0) );
		return true;
	}
	if( i==63 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_rotate(p0) );
		return true;
	}
	if( i==64 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_preRotate(p0) );
		return true;
	}
	if( i==65 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_rotateX(p0) );
		return true;
	}
	if( i==66 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_rotateY(p0) );
		return true;
	}
	if( i==67 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_rotateZ(p0) );
		return true;
	}
	if( i==68 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_preRotateX(p0) );
		return true;
	}
	if( i==69 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_preRotateY(p0) );
		return true;
	}
	if( i==70 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_preRotateZ(p0) );
		return true;
	}
	if( i==71 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_preScale(p0) );
		return true;
	}
	if( i==72 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_translation(p0) );
		return true;
	}
	if( i==73 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_rotationX(p0) );
		return true;
	}
	if( i==74 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_rotationY(p0) );
		return true;
	}
	if( i==75 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_rotationZ(p0) );
		return true;
	}
	if( i==76 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_rotation(p0) );
		return true;
	}
	if( i==77 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_scaling(p0) );
		return true;
	}
	if( i==78 ) {
		SU_ASSERT( argc==1 && argv )
		SU_ASSERT( r )
		lua_State* p0 = (lua_State*)argv[0].asPointer();
		r->set( ((MLuaMath*)base)->ILuaMath_i.Lua_buildTR(p0) );
		return true;
	}
	return false;
}


}


// !! This file has been automatically generated by the sugar sidl tool.
// !! Do not edit this file manually under risk of losing your changes.

