
import os, sys, glob, socket
import getpass
import atmake
import atmake.tools.fs as fs
from . import components
from . import loader
from . import gencode as mod_gencode
from . import gendoc as mod_gendoc
from . import genproj as mod_genproj
from . import genbuild as mod_genbuild
from . import genuid as mod_genuid
from . import subst



ATBASE			= fs.Path( atmake.RelPath( r'../..' ) )
DEVCENTER_DIR	= fs.Path( ATBASE+r'/devcenter' )


gen_ro_warnings = '// !! This file has been automatically generated by the sugar sidl tool.\n' \
				+ '// !! Do not edit this file manually under risk of losing your changes.'




def build_default_env (	verbose=None, platform=None, env=None ) :

	""" hidden
	"""

	def env_tolower ( env, loc, arg ) :
		return arg.lower()

	def env_topathstring ( env, loc, arg ) :
		return arg.replace('\\','/')

	def env_toupper ( env, loc, arg ) :
		return arg.upper()

	def env_nospace ( env, loc, arg ) :
		return arg.replace(' ','')

	def env_dirname ( env, loc, arg ) :
		return os.path.dirname(arg)

	def env_basename ( env, loc, arg ) :
		return os.path.basename(arg)

	def env_curfile ( env, loc, arg ) :
		if loc and loc.filename:	return fs.Path(loc.filename)
		else:						return ''

	def env_curline ( env, loc, arg ) :
		if loc:		return loc.lineno
		else:		return 0

	def env_curdir ( env, loc, arg ) :
		if loc and loc.filename:	return fs.Path( os.path.dirname(loc.filename) )
		else:						return ''

	def env_isfile ( env, loc, arg ) :
		if os.path.isfile(arg):		return 1
		else:						return 0

	def env_isdir ( env, loc, arg ) :
		if os.path.isdir(arg):		return 1
		else:						return 0

	def env_osenviron ( env, loc, arg ) :
		if isinstance(arg,str) and arg in os.environ :		return os.environ[arg]
		else :												return ''

	e = components.SIDL_Env()

	wsname = os.getenv('COMPUTERNAME')
	hostname = socket.gethostname() or 'none'

	PFM = (platform or sys.platform).upper()
	if PFM=='WIN32':	PFM='WINDOWS'
	pfm = PFM.lower()

	# -- global vars
	e.SetVar( 'username',			getpass.getuser().lower()							)
	e.SetVar( 'wsname',				wsname												)
	e.SetVar( 'hostname',			hostname											)
	e.SetVar( 'buildroot',			ATBASE												)
	e.SetVar( 'outpath',			ATBASE												)
	e.SetVar( 'inpath',				ATBASE												)
	e.SetVar( 'devcenter',			DEVCENTER_DIR										)
	e.SetVar( 'path',				[]													)
	if verbose:
		e.SetVar( '__VERBOSE__',	1													)
	e.SetVar( '__REVISION__',		0													)
	e.SetVar( '__PLATFORM__',		PFM													)
	e.SetVar( '__platform__',		pfm													)
	e.SetVar( '__%s__'%pfm,			1													)
	e.SetVar( '__%s__'%PFM,			1													)

	# cpp tools vars
	e.SetVar( 'cpppath',			[]													)
	e.SetVar( 'cppdefines',			[]													)

	# interfaces
	e.SetVar( 'iclassroot',			'IInterface'										)
	e.SetVar( 'iclassname',			'doe'												)
	e.SetVar( 'iclassext',			'.h'												)
	e.SetVar( 'iclassoutfile',		'su_${tolower(${iclassname})}${iclassext}'			)
	e.SetVar( 'iclassoutpath',		'$outpath/$iclassoutfile'							)

	# implementations
	e.SetVar( 'mclassname',			'doe'												)
	e.SetVar( 'mclassext',			'.cpp'												)
	e.SetVar( 'mclassoutfile',		'su_${tolower(${mclassname})}_skel${mclassext}'		)
	e.SetVar( 'mclassoutpath',		'$outpath/$mclassoutfile'							)

	# implementation's or abstract's stubs
	e.SetVar( 'sclassext',			'.h'												)
	e.SetVar( 'sclassoutfile',		'su_${tolower(${mclassname})}_stub${sclassext}'		)
	e.SetVar( 'sclassoutpath',		'$outpath/$sclassoutfile'							)

	# implementation's builders
	e.SetVar( 'bclassext',			'.h'												)
	e.SetVar( 'bclassoutfile',		'su_${tolower(${mclassname})}_builder${sclassext}'	)
	e.SetVar( 'bclassoutpath',		'$outpath/$bclassoutfile'							)

	# test vars
	e.SetVar( 'testname',			'testdoe'											)
	e.SetVar( 'testext',			'.cpp'												)
	e.SetVar( 'testoutfile',		'${tolower(${testname})}${testext}'					)
	e.SetVar( 'testoutpath',		'$outpath/$testoutfile'								)
	e.SetVar( 'testsrunfilter', 	'*'													)

	# project vars
	e.SetVar( 'projname',			'projdoe'											)
	e.SetVar( 'projext',			''													)
	e.SetVar( 'projoutfile',		'${tolower(${projname})}${projext}'					)
	e.SetVar( 'projoutpath',		'$outpath/$projoutfile'								)
	e.SetVar( 'projtmpdir',			None												)

	# functions
	e.SetVar( 'tolower',			env_tolower											)
	e.SetVar( 'topathstring',		env_topathstring									)
	e.SetVar( 'toupper',			env_toupper											)
	e.SetVar( 'nospace',			env_nospace											)
	e.SetVar( 'dirname',			env_dirname											)
	e.SetVar( 'basename',			env_basename										)
	e.SetVar( 'isdir',				env_isdir											)
	e.SetVar( 'isfile',				env_isfile											)
	e.SetVar( 'env',				env_osenviron										)
	e.SetVar( '__file__',			env_curfile											)
	e.SetVar( '__dir__',			env_curdir											)
	e.SetVar( '__line__',			env_curline											)

	# overides using user globals !
	e.Update( env )
	return e

	



def pre_sidl ( sidlfile=None, shelffile=None, verbose=None, platform=None, env=None ) :

	""" hidden
	"""
	e = build_default_env( verbose=verbose, platform=platform, env=env )
	sidl, cpp = loader.SIDL_Load( sidlfile=sidlfile, shelffile=shelffile, env=e )
	return sidl, cpp


def post_sidl ( sidl=None ) :

	""" hidden
	"""

	# shelf writeback
	if sidl:
		sidl.ShelfSync()
	
	

	
	
	

def shelf (	sidlfile=None, shelffile=None, verbose=None, platform=None, env=None ) :

	"""	Display persistent informations (shelf objects) from a SIDL file.
		<sidlfile>  The main SIDL file to process
	"""

	sidl, cpp = pre_sidl( sidlfile=sidlfile, shelffile=shelffile, verbose=verbose, platform=platform, env=env )
	if sidl and sidl.shelf :
		for k,v in sidl.shelf.items() :
			for a,b in v.items() :
				print(a,':',b)



def files ( sidlfile=None, shelffile=None, verbose=None, platform=None, env=None ) :

	"""	Display generated files from a SIDL file.
		<sidlfile>  The main SIDL file to process
	"""

	sidl, cpp = pre_sidl( sidlfile=sidlfile, shelffile=shelffile, verbose=verbose, platform=platform, env=env )
	if sidl and sidl.shelf :
		ofiles = sorted( sidl.ShelfAccess( 'outfiles', {} ).keys() )
		for f in ofiles :
			if   fs.IsDirPath(f):		print("d '%s'" % f)
			elif fs.IsFilePath(f):		print("f '%s'" % f)
			else :						print("  '%s'" % f)



def clean (	sidlfile=None, shelffile=None, verbose=None, verboseonly=None, platform=None, env=None ) :

	"""	Removes all SIDL target files.
		<sidlfile>  The main SIDL file to process
	"""

	sidl, cpp = pre_sidl( sidlfile=sidlfile, shelffile=shelffile, verbose=verbose, platform=platform, env=env )
	if sidl and sidl.shelf :
		# remove the shelf file itself
		rfiles = [ sidl.shelffile ]
		# remove all outputed files, excluding user files !
		ofiles = sidl.ShelfAccess( 'outfiles', {} )
		for k,v in ofiles.items() :
			if v.get('cleanable',True) :
				rfiles.append( k )
		sidl.ShelfClose()
		for f in rfiles :
			# a file ?
			if fs.IsFilePath(f) :
				if not verboseonly:		fs.RmFile(f)
				if verbose:				print('File [%s] cleaned.'%f)
			# a directory
			elif fs.IsDirPath(f) :
				if not verboseonly:		fs.RmTree(f)
				if verbose:				print('Directory [%s] cleaned.'%f)
			# not found ?
			else :
				if verbose:				print('Unknown path [%s] skipped.'%f)



def dump ( sidlfile=None, shelffile=None, verbose=True, platform=None, env=None ) :

	"""	Dumps objects from an SIDL file.
		<sidlfile>  The main SIDL file to process
		<verbose>   Outputs some informations if True
	"""

	sidl, cpp = pre_sidl( sidlfile=sidlfile, shelffile=shelffile, verbose=verbose, platform=platform, env=env )
	if verbose :
		for l in str(sidl).splitlines() :
			print(l)



def gencode ( sidlfile=None, shelffile=None, verbose=None, platform=None, env=None, header=None, warnings=None, genline=True ) :

	"""	Generates source code for interfaces and implementations from an SIDL file.
		<sidlfile>  The main SIDL file to process
		<verbose>   Outputs some informations if True
		<genline>   Generate CPP #line directives
	"""
	env = env or {}
	env['__GENCODE__'] = 1
	sidl, cpp = pre_sidl( sidlfile=sidlfile, shelffile=shelffile, verbose=verbose, platform=platform, env=env )
	mod_gencode.SIDL_GenCode( sidl, header=header, warnings=warnings or gen_ro_warnings, verbose=verbose, generate_cpp_line_directive=genline )
	post_sidl( sidl )
	return sidl



def gendoc ( sidlfile=None, shelffile=None, verbose=None, platform=None, env=None ) :

	"""	Generates documentation files from an SIDL file.
		<sidlfile>  The main SIDL file to process
		<verbose>   Outputs some informations if True
	"""

	env = env or {}
	env['__GENDOC__']  = 1

	sidl, cpp = pre_sidl( sidlfile=sidlfile, shelffile=shelffile, verbose=verbose, platform=platform, env=env )
	mod_gendoc.SIDL_GenDoc( sidl, cpp, verbose=verbose )
	post_sidl( sidl )
	return sidl



def genproj	( solutionname=None, sidlfile=None, shelffile=None, verbose=None, precompiled=None, platform=None, env=None ) :

	"""	Generates project files from an SIDL file.
		<sidlfile>      The main SIDL file to process
		<verbose>       Outputs some informations if True
		<precompiled>	Enables support for precompiled headers. Default is True.
		<solutionname>  The solution name. This parameter is optionnal. If not defined, all solutions are generated.
	"""

	env = env or {}
	env['__GENPROJ__'] = 1

	sidl, cpp = pre_sidl( sidlfile=sidlfile, shelffile=shelffile, verbose=verbose, platform=platform, env=env )
	mod_genproj.SIDL_GenProj( sidl=sidl, solutionname=solutionname, verbose=verbose, precompiled=precompiled )
	post_sidl( sidl )
	return sidl


	
def genbuild ( sidlfile=None, shelffile=None, verbose=None, platform=None, env=None ) :
	"""	Load SIDL file for building.
		<sidlfile>      The main SIDL file to process
		<verbose>       Outputs some informations if True
	"""

	env = env or {}
	env['__BUILD__'] = 1

	sidl, cpp = pre_sidl( sidlfile=sidlfile, shelffile=shelffile, verbose=verbose, platform=platform, env=env )
	mod_genbuild.SIDL_GenBuild( sidl )
	post_sidl( sidl )
	return sidl

	
	

